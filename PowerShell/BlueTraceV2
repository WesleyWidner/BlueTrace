#################################################################################################################################
#################################################################################################################################

[CmdletBinding()]
param (
    [Parameter(Mandatory = $true)]
    [string[]]$Sections,

    [ValidateSet("CSV", "XLSX", "JSON", "TXT")]
    [string]$OutputFormat = "CSV",

    [Parameter(Mandatory = $true)]
    [string]$OutputFile,

    [string]$Password
)

# Split Sections if a single comma-separated string is provided
if ($Sections.Count -eq 1 -and $Sections[0] -like "*,*") {
    $Sections = $Sections[0] -split "," | ForEach-Object { $_.Trim() }
}

# Normalize OutputFormat to uppercase
$OutputFormat = $OutputFormat.ToUpper()

# Validate OutputFile is provided
if ([string]::IsNullOrEmpty($OutputFile)) {
    Write-Debug "OutputFile parameter cannot be null or empty."
    throw "OutputFile parameter cannot be null or empty."
}

# Ensure OutputFile has the expected extension based on OutputFormat
$ext = [IO.Path]::GetExtension($OutputFile)
$expectedExt = "." + $OutputFormat.ToLower()

if ([string]::IsNullOrEmpty($ext)) {
    $OutputFile += $expectedExt
    Write-Debug "Appended missing extension '$expectedExt' to OutputFile."
}
elseif ($ext.ToLower() -ne $expectedExt) {
    $OutputFile = [IO.Path]::ChangeExtension($OutputFile, $OutputFormat.ToLower())
    Write-Debug "Changed OutputFile extension to '$expectedExt'."
}

# Determine and validate output directory
$dir = Split-Path $OutputFile -Parent
if ([string]::IsNullOrEmpty($dir)) {
    $dir = Get-Location
    Write-Debug "Output directory not specified, using current location: $dir"
}

# Get the base name for the output file (without extension)
$baseName = [IO.Path]::GetFileNameWithoutExtension($OutputFile)

Write-Host "Processing sections: $Sections"
Write-Host "Output file: $OutputFile"
Write-Host "Base name: $baseName"

#################################################################################################################################
#################################################################################################################################

function Run-SystemInformation {
    try {
        $systemInfo = [PSCustomObject]@{
            Section         = "SystemInformation"
            Hostname        = $env:COMPUTERNAME
            UserDomain      = $env:USERDOMAIN
            Username        = $env:USERNAME
            SID             = ([System.Security.Principal.WindowsIdentity]::GetCurrent()).User.Value
            IsAdmin         = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
            SystemTimeLocal = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
            SystemTimeUTC   = (Get-Date).ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")
            TimeZone        = (Get-TimeZone).Id
            BootTime        = (Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop).LastBootUpTime.ToString("yyyy-MM-dd HH:mm:ss")
        }
        return @($systemInfo)
    } catch {
        Write-Warning "Error collecting SystemInformation: $($_.Exception.Message)"
        return $null
    }
}

##################################################################################################################################################################################################################################################################

function Run-InstalledPrograms {
    $registryPaths = @(
        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*",
        "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*",
        "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*"
    )
    $installedPrograms = New-Object System.Collections.ArrayList
    foreach ($path in $registryPaths) {
        try {
            $items = Get-ItemProperty -Path $path -ErrorAction Stop | Where-Object { 
                $_.DisplayName -and $_.DisplayName.Trim() -ne "" 
            } | ForEach-Object {
                [PSCustomObject]@{
                    Section        = "InstalledPrograms"
                    DisplayName    = $_.DisplayName
                    DisplayVersion = $_.DisplayVersion
                    Publisher      = $_.Publisher
                    InstallDate    = if ($_.InstallDate -match '^\d{8}$') {
                        try {
                            [datetime]::ParseExact($_.InstallDate, 'yyyyMMdd', $null).ToString('yyyy-MM-dd')
                        } catch {
                            $_.InstallDate
                        }
                    } else {
                        $_.InstallDate
                    }
                }
            }

            if ($items) {
                if ($items -isnot [System.Collections.ICollection]) { $items = @($items) }
                $installedPrograms.AddRange($items) | Out-Null
            }
        } catch {
            Write-Warning "Error collecting InstalledPrograms from '$path': $($_.Exception.Message)"
        }
    }

    if ($installedPrograms.Count -eq 0) {
        Write-Warning "No InstalledPrograms entries found."
        return $null
    } else {
        return $installedPrograms
    }
}

##################################################################################################################################################################################################################################################################

function Run-EnvironmentVariables {
    $envVars = New-Object System.Collections.ArrayList

    try {
        [System.Environment]::GetEnvironmentVariables("User").GetEnumerator() | ForEach-Object {
            $envVars.Add([PSCustomObject]@{
                Section = "EnvironmentVariables"
                Scope   = "User"
                Name    = $_.Key
                Value   = $_.Value
            }) | Out-Null
        }
    } catch {
        Write-Warning "Error collecting EnvironmentVariables (User scope): $($_.Exception.Message)"
    }

    try {
        [System.Environment]::GetEnvironmentVariables("Machine").GetEnumerator() | ForEach-Object {
            $envVars.Add([PSCustomObject]@{
                Section = "EnvironmentVariables"
                Scope   = "System"
                Name    = $_.Key
                Value   = $_.Value
            }) | Out-Null
        }
    } catch {
        Write-Warning "Error collecting EnvironmentVariables (System scope): $($_.Exception.Message)"
    }

    if ($envVars.Count -eq 0) {
        Write-Warning "No EnvironmentVariables entries found."
        return $null
    } else {
        return $envVars
    }
}



##################################################################################################################################################################################################################################################################

function Run-UACSettings {
    $uacSettings = New-Object System.Collections.ArrayList

    try {
        $uacRegistryPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System"
        $uac = Get-ItemProperty -Path $uacRegistryPath -ErrorAction Stop

        $uacSettings.Add([PSCustomObject]@{
            Section                    = "UACSettings"
            ConsentPromptBehaviorAdmin = switch ($uac.ConsentPromptBehaviorAdmin) {
                0 { "No Prompt (Elevate silently)" }
                1 { "Prompt for credentials on secure desktop" }
                2 { "Prompt for consent on secure desktop" }
                3 { "Prompt for credentials" }
                4 { "Prompt for consent" }
                5 { "Prompt for consent for non-Windows binaries" }
                default { "Unknown" }
            }
            ConsentPromptBehaviorUser = switch ($uac.ConsentPromptBehaviorUser) {
                0 { "Automatically deny elevation" }
                1 { "Prompt for credentials on secure desktop" }
                3 { "Prompt for consent" }
                default { "Unknown" }
            }
            EnableLUA                   = if ($uac.EnableLUA -eq 1) { "UAC Enabled" } else { "UAC Disabled" }
            PromptOnSecureDesktop       = if ($uac.PromptOnSecureDesktop -eq 1) { "Secure desktop ON" } else { "Secure desktop OFF" }
            EnableVirtualization        = if ($uac.EnableVirtualization -eq 1) { "Enabled" } else { "Disabled" }
            ValidateAdminCodeSignatures = if ($uac.ValidateAdminCodeSignatures -eq 1) { "Validation Required" } else { "Not Required" }
            FilterAdministratorToken    = if ($uac.FilterAdministratorToken -eq 1) { "Split Token" } else { "Full Token" }
        }) | Out-Null
    } catch {
        Write-Warning "Error collecting UACSettings: $($_.Exception.Message)"
    }

    if ($uacSettings.Count -eq 0) {
        Write-Warning "No UACSettings entries found."
        return $null
    } else {
        return $uacSettings
    }
}

##################################################################################################################################################################################################################################################################

function Run-WindowsVersionInfo {
    $winInfo = New-Object System.Collections.ArrayList

    function Safe-ToDateTime {
        param ($dmtfDate)
        if ([string]::IsNullOrWhiteSpace($dmtfDate) -or $dmtfDate -notmatch '^\d{14}\.') {
            return "Unavailable"
        }
        try {
            return [Management.ManagementDateTimeConverter]::ToDateTime($dmtfDate).ToString("yyyy-MM-dd HH:mm:ss")
        } catch {
            return "Invalid Format"
        }
    }

    try {
        $os = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop

        $winInfo.Add([PSCustomObject]@{
            Section        = "WindowsVersionInfo"
            Caption        = $os.Caption
            Version        = $os.Version
            BuildNumber    = $os.BuildNumber
            Architecture   = $os.OSArchitecture
            InstallDate    = Safe-ToDateTime $os.InstallDate
            LastBootUpTime = Safe-ToDateTime $os.LastBootUpTime
        }) | Out-Null
    } catch {
        Write-Warning "Error collecting WindowsVersionInfo: $($_.Exception.Message)"
    }

    if ($winInfo.Count -eq 0) {
        Write-Warning "No WindowsVersionInfo entries found."
        return $null
    } else {
        return $winInfo
    }
}

##################################################################################################################################################################################################################################################################

function Run-DesktopFileTimestamps {
    $results = New-Object System.Collections.ArrayList

    try {
        $targetPath = [Environment]::GetFolderPath("Desktop")
        $files = Get-ChildItem -Path $targetPath -File -ErrorAction SilentlyContinue

        foreach ($file in $files) {
            $hash = ""
            try {
                $hash = (Get-FileHash -Path $file.FullName -Algorithm SHA256 -ErrorAction SilentlyContinue).Hash
            } catch {
                $hash = "Error generating hash"
            }

            $results.Add([PSCustomObject]@{
                Section      = "DesktopFileTimestamps"
                Name         = $file.Name
                FullPath     = $file.FullName
                LastModified = $file.LastWriteTime.ToString("yyyy-MM-dd HH:mm:ss")
                SHA256       = $hash
            }) | Out-Null
        }
    } catch {
        Write-Warning "Error collecting DesktopFileTimestamps: $($_.Exception.Message)"
    }

    if ($results.Count -eq 0) {
        Write-Warning "No DesktopFileTimestamps entries found."
        return $null
    } else {
        return $results
    }
}

##################################################################################################################################################################################################################################################################

function Run-FileMetadata {
    $fileTimeData = New-Object System.Collections.ArrayList

    try {
        $userPath = $env:USERPROFILE
        $allFiles = Get-ChildItem -Path $userPath -Recurse -File -Force -ErrorAction Stop

        foreach ($file in $allFiles) {
            $hash = ""
            try {
                $hash = (Get-FileHash -Path $file.FullName -Algorithm SHA256 -ErrorAction SilentlyContinue).Hash
            } catch {
                $hash = "Error generating hash"
            }

            $fileTimeData.Add([PSCustomObject]@{
                Section      = "FileMetadata"
                Name         = $file.Name
                FullPath     = $file.FullName
                CreationTime = $file.CreationTime.ToString("yyyy-MM-dd HH:mm:ss")
                LastModified = $file.LastWriteTime.ToString("yyyy-MM-dd HH:mm:ss")
                LastAccessed = $file.LastAccessTime.ToString("yyyy-MM-dd HH:mm:ss")
                SHA256       = $hash
            }) | Out-Null
        }
    } catch {
        Write-Warning "Error collecting FileMetadata: $($_.Exception.Message)"
    }

    if ($fileTimeData.Count -eq 0) {
        Write-Warning "No FileMetadata entries found."
        return $null
    } else {
        return $fileTimeData
    }
}

##################################################################################################################################################################################################################################################################

function Run-HiddenFilesOnC {
    $hiddenData = New-Object System.Collections.ArrayList

    try {
        $hiddenFiles = Get-ChildItem -Path "C:\" -Recurse -File -Force -ErrorAction SilentlyContinue |
            Where-Object { $_.Attributes -band [System.IO.FileAttributes]::Hidden }

        foreach ($file in $hiddenFiles) {
            try {
                $hash = ""
                try {
                    $hash = (Get-FileHash -Path $file.FullName -Algorithm SHA256 -ErrorAction SilentlyContinue).Hash
                } catch {
                    $hash = "Error generating hash"
                }

                $hiddenData.Add([PSCustomObject]@{
                    Section   = "HiddenFilesOnC"
                    FullName  = $file.FullName
                    SizeKB    = [math]::Round($file.Length / 1KB, 2)
                    Created   = $file.CreationTime.ToString("yyyy-MM-dd HH:mm:ss")
                    Modified  = $file.LastWriteTime.ToString("yyyy-MM-dd HH:mm:ss")
                    Accessed  = $file.LastAccessTime.ToString("yyyy-MM-dd HH:mm:ss")
                    SHA256    = $hash
                }) | Out-Null
            } catch {
                Write-Warning "Error processing hidden file in HiddenFilesOnC: $($_.Exception.Message)"
            }
        }
    } catch {
        Write-Warning "Error collecting HiddenFilesOnC: $($_.Exception.Message)"
        return $null
    }

    if ($hiddenData.Count -eq 0) {
        Write-Warning "No HiddenFilesOnC entries found."
        return $null
    } else {
        return $hiddenData
    }
}

##################################################################################################################################################################################################################################################################

function Run-AlternateDataStreams {
    $adsResults = New-Object System.Collections.ArrayList

    try {
        $adsPath = [Environment]::GetFolderPath("Desktop")
        $files = Get-ChildItem -Path $adsPath -Recurse -File -Force -ErrorAction Stop

        foreach ($file in $files) {
            try {
                $streams = Get-Item -Path $file.FullName -Stream * -ErrorAction SilentlyContinue
                foreach ($stream in $streams) {
                    if ($stream.Stream -ne '::$DATA') {
                        $hash = ""
                        try {
                            $hash = (Get-FileHash -Path $file.FullName -Algorithm SHA256 -ErrorAction SilentlyContinue).Hash
                        } catch {
                            $hash = "Error generating hash"
                        }

                        $adsResults.Add([PSCustomObject]@{
                            Section = "AlternateDataStreams"
                            File    = $file.FullName
                            Stream  = $stream.Stream
                            Length  = $stream.Length
                            SHA256  = $hash
                        }) | Out-Null
                    }
                }
            } catch {
                Write-Warning "Error retrieving streams for file in AlternateDataStreams: $($file.FullName) - $($_.Exception.Message)"
            }
        }
    } catch {
        Write-Warning "Error collecting AlternateDataStreams: $($_.Exception.Message)"
        return $null
    }

    if ($adsResults.Count -gt 0) {
        return $adsResults
    } else {
        return $null
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-FilesAccessedLast14Days {
    $daysBack = 14
    $cutoffDate = (Get-Date).AddDays(-$daysBack)
    $targetPath = "C:\"
    $recentlyAccessed = New-Object System.Collections.ArrayList

    try {
        Get-ChildItem -Path $targetPath -Recurse -File -Force -ErrorAction SilentlyContinue | ForEach-Object {
            try {
                if ($_.LastAccessTime -gt $cutoffDate) {
                    $hash = ""
                    try {
                        $hash = (Get-FileHash -Path $_.FullName -Algorithm SHA256 -ErrorAction SilentlyContinue).Hash
                    } catch {
                        $hash = "Error generating hash"
                    }

                    $recentlyAccessed.Add([PSCustomObject]@{
                        Section        = "FilesAccessedLast14Days"
                        FullName       = $_.FullName
                        LastAccessTime = $_.LastAccessTime
                        SizeKB         = [math]::Round($_.Length / 1KB, 2)
                        LastWriteTime  = $_.LastWriteTime
                        Created        = $_.CreationTime
                        SHA256         = $hash
                    }) | Out-Null
                }
            } catch {
                Write-Warning "Error processing file in FilesAccessedLast14Days: $($_.FullName) - $($_.Exception.Message)"
            }
        }
    } catch {
        Write-Warning "Error collecting FilesAccessedLast14Days: $($_.Exception.Message)"
        return $null
    }

    if ($recentlyAccessed.Count -eq 0) {
        return $null
    } else {
        return $recentlyAccessed
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-RecycleBinContents {
    $recycleBinData = New-Object System.Collections.ArrayList

    try {
        $shell = New-Object -ComObject Shell.Application
        $recycleBin = $shell.Namespace(0xA)
        if (-not $recycleBin) {
            Write-Warning "Recycle Bin namespace not available."
            return $null
        }

        $items = $recycleBin.Items()
        if (-not $items) {
            Write-Warning "No items found in the Recycle Bin."
            return $null
        }

        $total = $items.Count
        for ($i = 0; $i -lt $total; $i++) {
            try {
                $item = $items.Item($i)
                
                $hash = ""
                try {
                    $originalPath = $recycleBin.GetDetailsOf($item, 1)
                    if (Test-Path $originalPath) {
                        $hash = (Get-FileHash -Path $originalPath -Algorithm SHA256 -ErrorAction SilentlyContinue).Hash
                    } else {
                        $hash = "Original file not accessible"
                    }
                } catch {
                    $hash = "Error generating hash"
                }

                $recycleBinData.Add([PSCustomObject]@{
                    Section      = "RecycleBinContents"
                    OriginalPath = $recycleBin.GetDetailsOf($item, 1)
                    DeletedDate  = $recycleBin.GetDetailsOf($item, 2)
                    SizeBytes    = $recycleBin.GetDetailsOf($item, 3)
                    Name         = $item.Name
                    SHA256       = $hash
                }) | Out-Null
            } catch {
                Write-Warning "Error processing item in RecycleBinContents: $($_.Exception.Message)"
            }
        }

    } catch {
        Write-Warning "Error collecting RecycleBinContents: $($_.Exception.Message)"
        return $null
    }

    if ($recycleBinData.Count -eq 0) {
        Write-Warning "Recycle Bin is empty."
        return $null
    } else {
        return $recycleBinData
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-TempFolderContents {
    $tempFiles = New-Object System.Collections.ArrayList
    $tempPath = $env:TEMP

    try {
        $items = Get-ChildItem -Path $tempPath -Recurse -Force -ErrorAction Stop
        foreach ($item in $items) {
            try {
                if ($item.PSIsContainer) { continue }

                $hash = ""
                try {
                    $hash = (Get-FileHash -Path $item.FullName -Algorithm SHA256 -ErrorAction SilentlyContinue).Hash
                } catch {
                    $hash = "Error generating hash"
                }

                $tempFiles.Add([PSCustomObject]@{
                    Section       = "TempFolderContents"
                    FullName      = $item.FullName
                    Length        = $item.Length
                    LastWriteTime = $item.LastWriteTime.ToString("yyyy-MM-dd HH:mm:ss")
                    SHA256        = $hash
                }) | Out-Null
            } catch {
                Write-Warning "Error processing file in TempFolderContents: $($item.FullName) - $($_.Exception.Message)"
            }
        }

    } catch {
        Write-Warning "Error collecting TempFolderContents: $($_.Exception.Message)"
        return $null
    }

    $tempFiles = $tempFiles | Sort-Object LastWriteTime -Descending
    if ($tempFiles.Count -eq 0) {
        Write-Warning "No files found in TempFolderContents: $tempPath"
        return $null
    } else {
        return $tempFiles
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-VolumeShadowCopies {
    $shadowCopies = New-Object System.Collections.ArrayList

    try {
        $shadowInstances = Get-CimInstance -Namespace "root\cimv2" -ClassName Win32_ShadowCopy -ErrorAction Stop
        foreach ($shadow in $shadowInstances) {
            $shadowCopies.Add([PSCustomObject]@{
                Section     = "VolumeShadowCopies"
                ID          = $shadow.ID
                VolumeName  = $shadow.VolumeName
                InstallDate = $shadow.InstallDate
            }) | Out-Null
        }

        if ($shadowCopies.Count -eq 0) {
            Write-Warning "No Volume Shadow Copies found via WMI."
            return $null
        } else {
            return $shadowCopies
        }
    } catch {
        Write-Warning "Error collecting VolumeShadowCopies (WMI): $($_.Exception.Message). Trying fallback (vssadmin)..."
        try {
            $vssOutput = vssadmin list shadows 2>&1
            $current = @{}
            foreach ($line in $vssOutput) {
                if ($line -match "Shadow Copy ID:\s+({.*})") {
                    $current.ID = $matches[1]
                } elseif ($line -match "Original Volume:\s+(.*)") {
                    $current.VolumeName = $matches[1]
                } elseif ($line -match "Creation Time:\s+(.*)") {
                    $current.InstallDate = $matches[1]
                    $shadowCopies.Add([PSCustomObject]@{
                        Section     = "VolumeShadowCopies"
                        ID          = $current.ID
                        VolumeName  = $current.VolumeName
                        InstallDate = $current.InstallDate
                    }) | Out-Null
                    $current = @{}
                }
            }

            if ($shadowCopies.Count -eq 0) {
                Write-Warning "No Volume Shadow Copies found using vssadmin."
                return $null
            } else {
                return $shadowCopies
            }
        } catch {
            Write-Warning "Error collecting VolumeShadowCopies (vssadmin): $($_.Exception.Message)"
            return $null
        }
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-SymbolicLinksAndJunctions {
    $reparsePoints = New-Object System.Collections.ArrayList
    $targetPath = "C:\"

    try {
        $items = Get-ChildItem -Path $targetPath -Recurse -Force -ErrorAction Stop
        $items | Where-Object { $_.Attributes -band [System.IO.FileAttributes]::ReparsePoint } | ForEach-Object {
            $reparsePoints.Add([PSCustomObject]@{
                Section    = "SymbolicLinksAndJunctions"
                FullName   = $_.FullName
                Attributes = $_.Attributes.ToString()
                LinkType   = if ($_.PSIsContainer) { "Junction" } else { "SymbolicLink" }
            }) | Out-Null
        }
    } catch {
        Write-Warning "Error collecting SymbolicLinksAndJunctions: $($_.Exception.Message)"
    }

    if ($reparsePoints.Count -eq 0) {
        Write-Warning "No symbolic links or junctions found in SymbolicLinksAndJunctions: $targetPath"
        return $null
    } else {
        return $reparsePoints
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-RunningProcesses {
    $processList = New-Object System.Collections.ArrayList

    try {
        Get-Process | ForEach-Object {
            $proc = $_
            $name = $proc.Name
            $id   = $proc.Id
            $path = "ACCESS_DENIED"
            $startTime = "ACCESS_DENIED"
            try {
                if ($proc.PSObject.Properties.Match('Path')) {
                    $path = $proc.Path
                    if (-not $path) { $path = "N/A" }
                }
            } catch {
                $path = "ACCESS_DENIED"
            }
            try {
                $startTime = $proc.StartTime.ToString("yyyy-MM-dd HH:mm:ss")
            } catch {
                $startTime = "ACCESS_DENIED"
            }
            $processList.Add([PSCustomObject]@{
                Section   = "RunningProcesses"
                Name      = $name
                Id        = $id
                Path      = $path
                StartTime = $startTime
            }) | Out-Null
        }

    } catch {
        Write-Warning "Error collecting RunningProcesses: $($_.Exception.Message)"
        return $null
    }

    $processList = $processList | Sort-Object Name
    if ($processList.Count -eq 0) {
        Write-Warning "No running processes found in RunningProcesses."
        return $null
    } else {
        return $processList
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-LoadedDLLs {
    function Get-FileHashSafe {
        param ($path)
        try {
            if (Test-Path $path) {
                return (Get-FileHash -Algorithm SHA256 -Path $path -ErrorAction Stop).Hash
            } else {
                return "N/A"
            }
        } catch {
            return "HashError"
        }
    }

    function Get-SignatureStatus {
        param ($path)
        try {
            if (Test-Path $path) {
                $sig = Get-AuthenticodeSignature -FilePath $path -ErrorAction Stop
                return $sig.Status.ToString()
            } else {
                return "N/A"
            }
        } catch {
            return "SigError"
        }
    }

    function Get-CompanyName {
        param ($path)
        try {
            if (Test-Path $path) {
                return (Get-Item -Path $path).VersionInfo.CompanyName
            } else {
                return "N/A"
            }
        } catch {
            return "Error"
        }
    }

    $dllList = New-Object System.Collections.ArrayList

    try {
        $allProcesses = Get-Process -ErrorAction SilentlyContinue
        foreach ($proc in $allProcesses) {
            try {
                foreach ($mod in $proc.Modules) {
                    $hash = Get-FileHashSafe -path $mod.FileName
                    $sig  = Get-SignatureStatus -path $mod.FileName
                    $company = Get-CompanyName -path $mod.FileName
                    $suspiciousPath = if ($mod.FileName -match "AppData|Temp|Roaming|Downloads") { $true } else { $false }
                    $dllList.Add([PSCustomObject]@{
                        Section        = "LoadedDLLs"
                        ProcessName    = $proc.Name
                        PID            = $proc.Id
                        ModuleName     = $mod.ModuleName
                        FilePath       = $mod.FileName
                        SHA256         = $hash
                        Signature      = $sig
                        CompanyName    = $company
                        SuspiciousPath = $suspiciousPath
                    }) | Out-Null
                }
            } catch {
                Write-Warning "Error collecting modules for process in LoadedDLLs: $($proc.Name) - $($_.Exception.Message)"
                $dllList.Add([PSCustomObject]@{
                    Section        = "LoadedDLLs"
                    ProcessName    = $proc.Name
                    PID            = $proc.Id
                    ModuleName     = "[ACCESS DENIED]"
                    FilePath       = "N/A"
                    SHA256         = "N/A"
                    Signature      = "N/A"
                    CompanyName    = "N/A"
                    SuspiciousPath = $false
                }) | Out-Null
            }
        }

    } catch {
        Write-Warning "Error collecting LoadedDLLs: $($_.Exception.Message)"
        return $null
    }

    if ($dllList.Count -eq 0) {
        Write-Warning "No DLLs found or access denied for all processes in LoadedDLLs."
        return $null
    } else {
        return $dllList
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-ProcessTreeWMI {
    $processTree = New-Object System.Collections.ArrayList

    try {
        $wmiProcs = Get-WmiObject Win32_Process -ErrorAction Stop
        foreach ($proc in $wmiProcs) {
            try {
                $name       = $proc.Name
                $pid        = $proc.ProcessId
                $ppid       = $proc.ParentProcessId
                $cmdline    = if ($proc.CommandLine) { $proc.CommandLine } else { "Unavailable" }
                $startTime  = "Unavailable"
                $user       = "Unavailable"

                try {
                    if ($proc.CreationDate -and $proc.CreationDate -match '^\d{14}\.\d{6}\+\d{3}$') {
                        $startTime = [System.Management.ManagementDateTimeConverter]::ToDateTime($proc.CreationDate).ToString("yyyy-MM-dd HH:mm:ss")
                    }
                } catch {
                    $startTime = "Unavailable"
                }

                try {
                    $owner = $proc.GetOwner()
                    if ($owner.User) {
                        $user = "$($owner.Domain)\$($owner.User)"
                    }
                } catch {
                    $user = "Unavailable"
                }

                $processTree.Add([PSCustomObject]@{
                    Section      = "ProcessTreeWMI"
                    Name         = $name
                    PID          = $pid
                    ParentPID    = $ppid
                    CommandLine  = $cmdline
                    StartTime    = $startTime
                    User         = $user
                }) | Out-Null
            } catch {
                Write-Warning "Error processing entry in ProcessTreeWMI: $($_.Exception.Message)"
            }
        }
    } catch {
        Write-Warning "Error collecting ProcessTreeWMI: $($_.Exception.Message)"
        return $null
    }

    if ($processTree.Count -eq 0) {
        Write-Warning "No processes found in ProcessTreeWMI."
        return $null
    } else {
        return $processTree
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-PowerShellHistory {
    $psHistory = New-Object System.Collections.ArrayList
    $transcriptPaths = @(
        "$env:USERPROFILE\Documents\PowerShell_transcript.*.txt",
        "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt"
    )
    $transcriptFound = $false

    foreach ($path in $transcriptPaths) {
        $files = @(Get-ChildItem -Path $path -ErrorAction SilentlyContinue)
        foreach ($file in $files) {
            try {
                $lines = Get-Content $file.FullName -ErrorAction Stop
                $lineNum = 0
                foreach ($line in $lines) {
                    $lineNum++
                    $psHistory.Add([PSCustomObject]@{
                        Section    = "PowerShellHistory"
                        Timestamp  = (Get-Item $file.FullName -ErrorAction SilentlyContinue).LastWriteTime
                        LineNumber = $lineNum
                        Command    = $line
                    }) | Out-Null
                }
                $transcriptFound = $true
            } catch {
                Write-Warning "Error collecting PowerShellHistory from file in PowerShellHistory: $($file.FullName) - $($_.Exception.Message)"
            }
        }
    }

    if (-not $transcriptFound) {
        $histFile = "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt"
        if (Test-Path $histFile) {
            try {
                $lines = Get-Content $histFile -ErrorAction Stop
                $lineNum = 0
                foreach ($line in $lines) {
                    $lineNum++
                    $psHistory.Add([PSCustomObject]@{
                        Section    = "PowerShellHistory"
                        Timestamp  = (Get-Item $histFile -ErrorAction SilentlyContinue).LastWriteTime
                        LineNumber = $lineNum
                        Command    = $line
                    }) | Out-Null
                }
            } catch {
                Write-Warning "Error collecting PowerShellHistory from fallback in PowerShellHistory: $histFile - $($_.Exception.Message)"
            }
        } else {
            Write-Warning "No PowerShell history files found in PowerShellHistory."
        }
    }

    if ($psHistory.Count -eq 0) {
        return $null
    } else {
        return $psHistory
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-ParentChildProcessTree {
    $processTree = New-Object System.Collections.Generic.List[object]

    try {
        $allProcs = Get-CimInstance Win32_Process -ErrorAction Stop
        foreach ($proc in $allProcs) {
            try {
                $creationDate = "Unavailable"
                try {
                    if ($proc.CreationDate) {
                        $creationDate = [Management.ManagementDateTimeConverter]::ToDateTime($proc.CreationDate).ToString("yyyy-MM-dd HH:mm:ss")
                    }
                } catch {
                    Write-Warning "Error parsing CreationDate for process in ParentChildProcessTree: $($proc.Name) - $($_.Exception.Message)"
                }

                $processTree.Add([PSCustomObject]@{
                    Section         = "ParentChildProcessTree"
                    ProcessName     = $proc.Name
                    ProcessId       = $proc.ProcessId
                    ParentProcessId = $proc.ParentProcessId
                    ExecutablePath  = $proc.ExecutablePath
                    CommandLine     = $proc.CommandLine
                    CreationDate    = $creationDate
                }) | Out-Null
            } catch {
                Write-Warning "Error collecting ParentChildProcessTree info for process in ParentChildProcessTree: $($proc.Name) - $($_.Exception.Message)"
            }
        }

        # Sorting: Treat "Unavailable" as MinValue for stable sorting
        $sortedTree = $processTree | Sort-Object {
            if ($_.CreationDate -eq "Unavailable") {
                [datetime]::MinValue
            } else {
                try { [datetime]$_.CreationDate } catch { [datetime]::MinValue }
            }
        }

        if ($sortedTree.Count -eq 0) {
            Write-Warning "No process tree data found in ParentChildProcessTree."
            return $null
        } else {
            return $sortedTree
        }
    } catch {
        Write-Warning "Error collecting ParentChildProcessTree: $($_.Exception.Message)"
        return $null
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-WmiActivityLogs {
    $logName = "Microsoft-Windows-WMI-Activity/Operational"
    $wmiEvents = New-Object System.Collections.ArrayList

    try {
        $logStatus = Get-WinEvent -ListLog $logName -ErrorAction SilentlyContinue
        if (-not $logStatus -or $logStatus.IsEnabled -eq $false) {
            Write-Warning "WMI Activity Log not found or not enabled in WmiActivityLogs: $logName"
            return $null
        }

        $events = Get-WinEvent -LogName $logName -MaxEvents 100 -ErrorAction Stop
        foreach ($evt in $events) {
            try {
                $eventXml = [xml]$evt.ToXml()
                $data = $eventXml.Event.EventData.Data
                $eventId = $evt.Id
                $eventType = switch ($eventId) {
                    5857 { "Query Execution Started" }
                    5858 { "Query Execution Completed" }
                    5859 { "Query Execution Error" }
                    5860 { "Query Cancelled" }
                    5861 { "Consumer Initialization" }
                    5862 { "Consumer Deactivation" }
                    default { "Other/Unknown" }
                }
                $processId = if ($data.Count -gt 0) { $data[0].'#text' } else { "Unavailable" }
                $user      = if ($data.Count -gt 1) { $data[1].'#text' } else { "Unavailable" }
                $operation = if ($data.Count -gt 2) { $data[2].'#text' } else { "Unavailable" }
                $namespace = if ($data.Count -gt 3) { $data[3].'#text' } else { "Unavailable" }
                $query     = if ($data.Count -gt 4) { $data[4].'#text' } else { "Unavailable" }

                $wmiEvents.Add([PSCustomObject]@{
                    Section     = "WmiActivityLogs"
                    TimeCreated = $evt.TimeCreated.ToString("yyyy-MM-dd HH:mm:ss")
                    EventID     = $eventId
                    EventType   = $eventType
                    ProcessID   = $processId
                    User        = $user
                    Operation   = $operation
                    Namespace   = $namespace
                    Query       = $query
                }) | Out-Null
            } catch {
                Write-Warning "Error parsing event in WmiActivityLogs (EventID: $($evt.Id)): $($_.Exception.Message)"
                $wmiEvents.Add([PSCustomObject]@{
                    Section     = "WmiActivityLogs"
                    TimeCreated = $evt.TimeCreated.ToString("yyyy-MM-dd HH:mm:ss")
                    EventID     = $evt.Id
                    EventType   = "ParseError"
                    Details     = "Error parsing XML or missing fields"
                }) | Out-Null
            }
        }

        if ($wmiEvents.Count -eq 0) {
            Write-Warning "No WMI activity events found in WmiActivityLogs: $logName"
            return $null
        } else {
            return $wmiEvents
        }
    } catch {
        Write-Warning "Error collecting WmiActivityLogs: $($_.Exception.Message)"
        return $null
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-ScheduledTasks {
    function Get-FileHashSafe {
        param ($path)
        try {
            if ($path -and -not [string]::IsNullOrWhiteSpace($path) -and (Test-Path -Path $path -PathType Leaf)) {
                return (Get-FileHash -Path $path -Algorithm SHA256 -ErrorAction Stop).Hash
            }
            return "Not Found"
        } catch {
            return "HashError"
        }
    }

    $scheduledTasks = New-Object System.Collections.ArrayList

    try {
        $allTasks = Get-ScheduledTask -ErrorAction Stop
        foreach ($task in $allTasks) {
            try {
                $info = Get-ScheduledTaskInfo -TaskName $task.TaskName -TaskPath $task.TaskPath -ErrorAction Stop
                $actions = ($task.Actions | ForEach-Object { $_.Execute -as [string] }) -join '; '
                $triggers = ($task.Triggers | ForEach-Object { $_.StartBoundary }) -join '; '
                $suspiciousPath = if ($actions -match "AppData|Temp|Downloads|\\Users\\.*\\") { $true } else { $false }
                $suspiciousTrigger = if ($triggers -match "01:|02:|03:|04:|AtLogon|AtStartup|Repetition") { $true } else { $false }
                $exePath = ($task.Actions | ForEach-Object { $_.Execute -as [string] })[0]
                $exePath = $exePath -replace '"', ''
                $exePath = $exePath.Trim()
                
                if ($exePath -and -not [string]::IsNullOrWhiteSpace($exePath) -and -not (Test-Path $exePath)) {
                    $resolved = Get-Command $exePath -ErrorAction SilentlyContinue
                    if ($resolved) { $exePath = $resolved.Source }
                }
                
                $sha256 = if ($exePath -and (Test-Path $exePath -PathType Leaf)) { Get-FileHashSafe -path $exePath } else { "N/A" }

                $scheduledTasks.Add([PSCustomObject]@{
                    Section           = "ScheduledTasks"
                    TaskName          = [string]$task.TaskName
                    TaskPath          = [string]$task.TaskPath
                    State             = [string]$task.State
                    LastRunTime       = if ($info.LastRunTime) { $info.LastRunTime.ToString("yyyy-MM-dd HH:mm:ss") } else { "Never" }
                    NextRunTime       = if ($info.NextRunTime) { $info.NextRunTime.ToString("yyyy-MM-dd HH:mm:ss") } else { "N/A" }
                    LastResult        = $info.LastTaskResult
                    Hidden            = [bool]$task.Settings.Hidden
                    Principal         = [string]$task.Principal.UserId
                    Action            = $actions
                    Trigger           = $triggers
                    SHA256            = $sha256
                    SuspiciousPath    = $suspiciousPath
                    SuspiciousTrigger = $suspiciousTrigger
                }) | Out-Null
            } catch {
                Write-Warning "Error collecting scheduled task in ScheduledTasks: $($task.TaskName) - $($_.Exception.Message)"
                
                $scheduledTasks.Add([PSCustomObject]@{
                    Section           = "ScheduledTasks"
                    TaskName          = [string]$task.TaskName
                    TaskPath          = [string]$task.TaskPath
                    State             = [string]$task.State
                    LastRunTime       = "Unavailable"
                    NextRunTime       = "Unavailable"
                    LastResult        = "Unavailable"
                    Hidden            = [bool]$task.Settings.Hidden
                    Principal         = [string]$task.Principal.UserId
                    Action            = "Unavailable"
                    Trigger           = "Unavailable"
                    SHA256            = "N/A"
                    SuspiciousPath    = $false
                    SuspiciousTrigger = $false
                }) | Out-Null
            }
        }

        if ($scheduledTasks.Count -eq 0) {
            Write-Warning "No scheduled tasks found in ScheduledTasks."
            return $null
        } else {
            return $scheduledTasks
        }
    } catch {
        Write-Warning "Error collecting ScheduledTasks: $($_.Exception.Message)"
        return $null
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-StartupFolderItems {
    function Get-FileHashSafe {
        param ($path)
        try {
            if (Test-Path $path -PathType Leaf) {
                return (Get-FileHash -Algorithm SHA256 -Path $path -ErrorAction Stop).Hash
            }
            return "Not Found"
        } catch {
            return "HashError"
        }
    }

    function Get-StartupItems {
        param ([string]$user, [string]$folder)
        $items = New-Object System.Collections.ArrayList
        if (Test-Path $folder) {
            Get-ChildItem -Path $folder -File -Force -ErrorAction SilentlyContinue | ForEach-Object {
                try {
                    $hash = Get-FileHashSafe -path $_.FullName
                    $suspicious = if ($_.FullName -match 'AppData|Temp|Roaming|Downloads|\.ps1|\.vbs|\.bat|\.cmd|\.js|\.lnk') { $true } else { $false }
                    $items.Add([PSCustomObject]@{
                        Section      = "StartupFolderItems"
                        User         = $user
                        ItemName     = $_.Name
                        FullPath     = $_.FullName
                        LastModified = $_.LastWriteTime
                        SHA256       = $hash
                        Suspicious   = $suspicious
                    }) | Out-Null
                } catch {
                    Write-Warning "Error collecting item in StartupFolderItems: $($_.FullName) - $($_.Exception.Message)"
                }
            }
        }
        return $items
    }

    $startupItems = New-Object System.Collections.ArrayList

    try {
        $currentUser = $env:USERNAME
        $currentUserPath = Join-Path $env:APPDATA "Microsoft\Windows\Start Menu\Programs\Startup"
        $startupItems.AddRange((Get-StartupItems -user $currentUser -folder $currentUserPath)) | Out-Null

        $commonStartup = "$env:ProgramData\Microsoft\Windows\Start Menu\Programs\Startup"
        $startupItems.AddRange((Get-StartupItems -user "AllUsers" -folder $commonStartup)) | Out-Null

        $profiles = Get-ChildItem "C:\Users" -Directory -ErrorAction SilentlyContinue
        foreach ($profile in $profiles) {
            $userName = $profile.Name
            $profileStartup = Join-Path $profile.FullName "AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup"
            $startupItems.AddRange((Get-StartupItems -user $userName -folder $profileStartup)) | Out-Null
        }

        $startupItems = $startupItems | Sort-Object FullPath -Unique

        if ($startupItems.Count -eq 0) {
            Write-Warning "No startup folder items found in StartupFolderItems."
            return $null
        } else {
            return $startupItems
        }
    } catch {
        Write-Warning "Error collecting StartupFolderItems: $($_.Exception.Message)"
        return $null
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-RegistryRunKeys {
    
    function Get-FileHashSafe {
        param ($path)
        try {
            if (Test-Path $path -PathType Leaf) {
                return (Get-FileHash -Algorithm SHA256 -Path $path -ErrorAction Stop).Hash
            }
            return "Not Found"
        } catch {
            return "HashError"
        }
    }

    function Extract-ExecutablePath {
        param ($commandLine)
        if ($commandLine -match '"([^"]+\.exe)"') {
            return $matches[1]
        } elseif ($commandLine -match '^([^\s]+\.exe)') {
            return $matches[1]
        } elseif ($commandLine -match '^rundll32\.exe\s+([^\s,]+)') {
            return $matches[1]
        } else {
            return $null
        }
    }

    $runKeys = @(
        "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run",
        "HKCU:\Software\Microsoft\Windows\CurrentVersion\RunOnce",
        "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run",
        "HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce"
    )

    $runEntries = New-Object System.Collections.ArrayList

    foreach ($key in $runKeys) {
        try {
            if (Test-Path $key) {
                Get-ItemProperty -Path $key -ErrorAction SilentlyContinue | ForEach-Object {
                    $_.PSObject.Properties | Where-Object { $_.Name -notin "PSPath","PSParentPath","PSChildName","PSDrive","PSProvider" } | ForEach-Object {
                        try {
                            $name = $_.Name
                            $val = $_.Value
                            $exePath = Extract-ExecutablePath $val
                            $hash = if ($exePath) { Get-FileHashSafe -path $exePath } else { "N/A" }
                            $suspicious = if ($val -match "AppData|Temp|Roaming|Downloads|\.bat|\.ps1|\.vbs|\.js|rundll32\.exe") { $true } else { $false }
                            
                            $runEntries.Add([PSCustomObject]@{
                                Section      = "RegistryRunKeys"
                                RegistryPath = $key
                                Name         = $name
                                Value        = $val
                                Executable   = $exePath
                                SHA256       = $hash
                                Suspicious   = $suspicious
                            }) | Out-Null
                        } catch {
                            Write-Warning "Error collecting item in RegistryRunKeys: [${key}, $($_.Name)] - $($_.Exception.Message)"
                        }
                    }
                }
            }
        } catch {
            Write-Warning "Error collecting RegistryRunKeys at ${key}: $($_.Exception.Message)"
        }
    }

    $runEntries = $runEntries | Sort-Object RegistryPath, Name, Value -Unique

    if ($runEntries.Count -eq 0) {
        Write-Warning "No registry run key entries found in RegistryRunKeys."
        return $null
    } else {
        return $runEntries
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-ServiceInformation {
    function Get-FileHashSafe {
        param ($path)
        try {
            if ($path -and (Test-Path $path -PathType Leaf)) {
                return (Get-FileHash -Path $path -Algorithm SHA256 -ErrorAction Stop).Hash
            }
            return "Not Found"
        } catch {
            return "HashError"
        }
    }

    function Get-SignatureInfo {
        param ($path)
        try {
            if (Test-Path $path -PathType Leaf) {
                $sig = Get-AuthenticodeSignature -FilePath $path
                return @{
                    IsSigned        = ($sig.Status -eq 'Valid')
                    SignatureStatus = $sig.Status.ToString()
                    Publisher       = $sig.SignerCertificate.Subject
                }
            }
        } catch {
            return @{
                IsSigned        = $false
                SignatureStatus = "CheckFailed"
                Publisher       = "Unknown"
            }
        }
        return @{
            IsSigned        = $false
            SignatureStatus = "NotFound"
            Publisher       = "None"
        }
    }

    function Extract-BinaryPath {
        param ($pathString)
        if ($pathString -match '"([^"]+\.exe)"') {
            return $matches[1]
        } elseif ($pathString -match '^([^\s]+\.exe)') {
            return $matches[1]
        } elseif ($pathString -match 'rundll32\.exe\s+([^\s,]+)') {
            return $matches[1]
        } else {
            return $null
        }
    }

    $services = New-Object System.Collections.ArrayList

    try {
        $allServices = Get-CimInstance Win32_Service -ErrorAction SilentlyContinue
        foreach ($svc in $allServices) {
            try {
                $exe = Extract-BinaryPath $svc.PathName
                $hash = if ($exe) { Get-FileHashSafe -path $exe } else { "N/A" }
                $sig = if ($exe) {
                    Get-SignatureInfo -path $exe
                } else {
                    @{
                        IsSigned        = $false
                        SignatureStatus = "N/A"
                        Publisher       = "N/A"
                    }
                }
                $suspicious = (
                    $svc.PathName -match "AppData|Temp|Roaming|Downloads|\.bat|\.vbs|\.ps1|\.js" -or
                    -not $sig.IsSigned
                )

                $services.Add([PSCustomObject]@{
                    Section         = "ServiceInformation"
                    Name            = $svc.Name
                    DisplayName     = $svc.DisplayName
                    State           = $svc.State
                    StartMode       = $svc.StartMode
                    PathName        = $svc.PathName
                    Executable      = $exe
                    SHA256          = $hash
                    IsSigned        = $sig.IsSigned
                    SignatureStatus = $sig.SignatureStatus
                    Publisher       = $sig.Publisher
                    Suspicious      = $suspicious
                    Description     = $svc.Description
                }) | Out-Null
            } catch {
                Write-Warning "Error processing service in ServiceInformation: [$($svc.Name)] - $($_.Exception.Message)"
            }
        }
    } catch {
        Write-Warning "Error collecting ServiceInformation: $($_.Exception.Message)"
        return $null
    }

    if ($services.Count -eq 0) {
        Write-Warning "No services found in ServiceInformation."
        return $null
    } else {
        return $services
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-WMIEventConsumers {
    $wmiConsumers = New-Object System.Collections.ArrayList

    try {
        $baseConsumers = Get-WmiObject -Namespace "root\\subscription" -Class __EventConsumer -ErrorAction Stop
        foreach ($consumer in $baseConsumers) {
            try {
                $exe = $null
                if ($consumer.PSObject.Properties.Match('CommandLine')) {
                    $cmd = $consumer.CommandLine
                    if ($cmd -match '"([^"]+\.exe)"') { $exe = $matches[1] }
                    elseif ($cmd -match '^(\S+\.exe)') { $exe = $matches[1] }
                }
                $suspicious = $false
                if ($consumer.PSObject.Properties.Match('CommandLine')) {
                    $suspicious = $consumer.CommandLine -match "AppData|Temp|Roaming|Downloads|powershell|cmd|wscript|cscript|\.vbs|\.ps1|\.bat|\.js"
                }

                $wmiConsumers.Add([PSCustomObject]@{
                    Section      = "WMIEventConsumers"
                    Name         = $consumer.Name
                    ConsumerType = $consumer.__CLASS
                    CommandLine  = if ($consumer.PSObject.Properties.Match('CommandLine')) { $consumer.CommandLine } else { "N/A" }
                    Executable   = if ($exe) { $exe } else { "N/A" }
                    Suspicious   = $suspicious
                }) | Out-Null
            } catch {
                Write-Warning "Error processing consumer in WMIEventConsumers: [$($consumer.Name)] - $($_.Exception.Message)"
            }
        }
    } catch {
        Write-Warning "Error collecting WMIEventConsumers: $($_.Exception.Message)"
    }

    if ($wmiConsumers.Count -eq 0) {
        Write-Warning "No WMI Event Consumers found in WMIEventConsumers."
        return $null
    } else {
        return $wmiConsumers
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-COMHijackingEntries {
    function Get-FileHashSafe {
        param ($path)
        try {
            if ($path -and (Test-Path $path -PathType Leaf)) {
                return (Get-FileHash -Path $path -Algorithm SHA256 -ErrorAction Stop).Hash
            }
            return "Not Found"
        } catch {
            return "HashError"
        }
    }

    function Get-SignatureInfo {
        param ($path)
        try {
            if (Test-Path $path -PathType Leaf) {
                $sig = Get-AuthenticodeSignature -FilePath $path
                return @{
                    IsSigned        = ($sig.Status -eq 'Valid')
                    SignatureStatus = $sig.Status.ToString()
                    Publisher       = $sig.SignerCertificate.Subject
                }
            }
        } catch {
            return @{
                IsSigned        = $false
                SignatureStatus = "CheckFailed"
                Publisher       = "Unknown"
            }
        }
        return @{
            IsSigned        = $false
            SignatureStatus = "NotFound"
            Publisher       = "None"
        }
    }

    $comHijackPaths = @(
        "HKCU:\Software\Classes\CLSID",
        "HKLM:\Software\Classes\CLSID"
    )

    $comHijackData = New-Object System.Collections.ArrayList

    foreach ($path in $comHijackPaths) {
        if (Test-Path $path) {
            Get-ChildItem -Path $path -ErrorAction SilentlyContinue | ForEach-Object {
                $clsidKey = $_.PSPath
                try {
                    $inprocPath = "$clsidKey\InprocServer32"
                    if (Test-Path $inprocPath) {
                        $inproc = Get-ItemProperty -Path $inprocPath -ErrorAction SilentlyContinue
                        $dll = $inproc.'(default)'
                        if (-not $dll) { $dll = $inproc.'' }
                        if ($dll -and $dll -ne "") {
                            $hash = Get-FileHashSafe -path $dll
                            $sig = Get-SignatureInfo -path $dll
                            $suspicious = (
                                $dll -match "AppData|Temp|Roaming|Downloads|\.ps1|\.bat|\.vbs|\.js" -or
                                -not $sig.IsSigned
                            )
                            $comHijackData.Add([PSCustomObject]@{
                                Section          = "COMHijackingEntries"
                                CLSIDPath        = $clsidKey
                                DLLPath          = $dll
                                SHA256           = $hash
                                IsSigned         = $sig.IsSigned
                                SignatureStatus  = $sig.SignatureStatus
                                Publisher        = $sig.Publisher
                                Suspicious       = $suspicious
                            }) | Out-Null
                        }
                    }
                } catch {
                    Write-Warning "Error processing entry in COMHijackingEntries: [$clsidKey] - $($_.Exception.Message)"
                }
            }
        } else {
            Write-Warning "COM hijack registry path not found in COMHijackingEntries: $path"
        }
    }

    if ($comHijackData.Count -eq 0) {
        Write-Warning "No COM hijacking entries found in COMHijackingEntries."
        return $null
    } else {
        return $comHijackData
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-DLLSearchOrderHijacks {
    function Get-FileHashSafe {
        param ($path)
        try {
            if (Test-Path $path -PathType Leaf) {
                return (Get-FileHash -Path $path -Algorithm SHA256 -ErrorAction Stop).Hash
            }
            return "Not Found"
        } catch {
            return "HashError"
        }
    }

    function Get-SignatureInfo {
        param ($path)
        try {
            if (Test-Path $path -PathType Leaf) {
                $sig = Get-AuthenticodeSignature -FilePath $path
                return @{
                    IsSigned        = ($sig.Status -eq 'Valid')
                    SignatureStatus = $sig.Status.ToString()
                    Publisher       = $sig.SignerCertificate.Subject
                }
            }
        } catch {
            return @{
                IsSigned        = $false
                SignatureStatus = "CheckFailed"
                Publisher       = "Unknown"
            }
        }
        return @{
            IsSigned        = $false
            SignatureStatus = "NotFound"
            Publisher       = "None"
        }
    }

    $dllDirs = @(
        "$env:SystemRoot",
        "$env:SystemRoot\System32",
        "$env:TEMP",
        "$env:APPDATA",
        "$env:USERPROFILE\AppData\Local",
        "$env:ProgramData"
    )

    $dllData = New-Object System.Collections.ArrayList

    foreach ($dir in $dllDirs) {
        if (Test-Path $dir) {
            try {
                Get-ChildItem -Path $dir -Filter *.dll -Recurse -Force -ErrorAction SilentlyContinue | ForEach-Object {
                    try {
                        $hash = Get-FileHashSafe -path $_.FullName
                        $sig = Get-SignatureInfo -path $_.FullName
                        $suspicious = (
                            $_.FullName -match "AppData|Temp|Roaming|Downloads" -or
                            -not $sig.IsSigned
                        )
                        $dllData.Add([PSCustomObject]@{
                            Section         = "DLLSearchOrderHijacks"
                            DLLName         = $_.Name
                            Path            = $_.FullName
                            LastWritten     = $_.LastWriteTime.ToString("yyyy-MM-dd HH:mm:ss")
                            SHA256          = $hash
                            IsSigned        = $sig.IsSigned
                            SignatureStatus = $sig.SignatureStatus
                            Publisher       = $sig.Publisher
                            Suspicious      = $suspicious
                        }) | Out-Null
                    } catch {
                        Write-Warning "Error processing file in DLLSearchOrderHijacks: $($_.FullName) - $($_.Exception.Message)"
                    }
                }
            } catch {
                Write-Warning "Error scanning directory in DLLSearchOrderHijacks: $dir - $($_.Exception.Message)"
            }
        } else {
            Write-Warning "DLL search directory not found in DLLSearchOrderHijacks: $dir"
        }
    }

    if ($dllData.Count -eq 0) {
        Write-Warning "No DLLs found in DLLSearchOrderHijacks."
        return $null
    } else {
        return $dllData
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-SecurityEventLog {
    function Get-SecurityEventMeaning {
        param ($id)
        switch ($id) {
            4624 { "Account Logon Success" }
            4625 { "Account Logon Failure" }
            4672 { "Special Privileges Assigned" }
            4688 { "New Process Created" }
            4634 { "Account Logoff" }
            4648 { "Explicit Credential Logon Attempt" }
            4768 { "Kerberos TGT Request" }
            4769 { "Kerberos Service Ticket Request" }
            4776 { "NTLM Authentication Attempt" }
            4689 { "Process Terminated" }
            4627 { "Group Membership Enumerated" }
            default { "Other / Unknown" }
        }
    }

    $securityLogs = New-Object System.Collections.ArrayList

    try {
        $entries = Get-WinEvent -LogName "Security" -MaxEvents 100 -ErrorAction Stop
        foreach ($entry in $entries) {
            try {
                $eid = $entry.Id
                $message = ($entry.Message -replace "`r`n", " ") -replace "\s{2,}", " "

                $securityLogs.Add([PSCustomObject]@{
                    Section         = "SecurityEventLog"
                    TimeCreated     = $entry.TimeCreated.ToString("yyyy-MM-dd HH:mm:ss")
                    EventID         = $eid
                    EventIDMeaning  = Get-SecurityEventMeaning $eid
                    Level           = $entry.LevelDisplayName
                    Message         = $message
                }) | Out-Null
            } catch {
                Write-Warning "Error parsing entry in SecurityEventLog (EventID $($entry.Id)): $($_.Exception.Message)"
            }
        }
    } catch {
        Write-Warning "Error collecting SecurityEventLog: $($_.Exception.Message)"
        return $null
    }

    if ($securityLogs.Count -eq 0) {
        Write-Warning "No Security event log entries found in SecurityEventLog."
        return $null
    } else {
        return $securityLogs
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-SystemEventLog {
    function Get-SystemEventMeaning {
        param ($id)
        switch ($id) {
            6005 { "Event Log Service Started" }
            6006 { "Event Log Service Stopped" }
            6008 { "Unexpected Shutdown" }
            7000 { "Service Failed to Start" }
            7001 { "Service Dependency Failed" }
            7023 { "Service Terminated Unexpectedly" }
            7040 { "Service Start Type Changed" }
            7045 { "Service Installed" }
            7026 { "Boot-start or system-start driver failed to load" }
            1014 { "DNS Name Resolution Timed Out" }
            7021 { "Connection telemetry event" }
            7003 { "Roam Complete" }
            6062 { "Low Power Idle Timeout Triggered" }
            default { "Unknown" }
        }
    }

    $systemLogs = New-Object System.Collections.ArrayList

    try {
        $entries = Get-WinEvent -LogName "System" -MaxEvents 100 -ErrorAction Stop
        foreach ($entry in $entries) {
            try {
                $eid = $entry.Id
                $message = ($entry.Message -replace "`r`n", " ") -replace "\s{2,}", " "

                $systemLogs.Add([PSCustomObject]@{
                    Section         = "SystemEventLog"
                    TimeCreated     = $entry.TimeCreated.ToString("yyyy-MM-dd HH:mm:ss")
                    EventID         = $eid
                    EventIDMeaning  = Get-SystemEventMeaning $eid
                    Level           = $entry.LevelDisplayName
                    Message         = $message
                }) | Out-Null
            } catch {
                Write-Warning "Error parsing entry in SystemEventLog (EventID $($entry.Id)): $($_.Exception.Message)"
            }
        }
    } catch {
        Write-Warning "Error collecting SystemEventLog: $($_.Exception.Message)"
        return $null
    }

    if ($systemLogs.Count -eq 0) {
        Write-Warning "No System event log entries found in SystemEventLog."
        return $null
    } else {
        return $systemLogs
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-ApplicationEventLog {
    function Get-AppEventMeaning {
        param ($id)
        switch ($id) {
            1000   { "Application Error / Crash" }
            1001   { "Application Hang / Fault Bucket" }
            1026   { ".NET Runtime Error" }
            11707  { "Application Installed" }
            11708  { "Application Install Failed" }
            16384  { "Software Protection Service Restart" }
            16394  { "Offline Licensing Succeeded" }
            1003   { "Software Protection Licensing Status" }
            default { "Unknown" }
        }
    }

    $appLogs = New-Object System.Collections.ArrayList

    try {
        $entries = Get-WinEvent -LogName "Application" -MaxEvents 100 -ErrorAction Stop
        foreach ($entry in $entries) {
            try {
                $eid = $entry.Id
                $cleanMsg = $entry.Message -replace "`r`n", " "
                $cleanMsg = $cleanMsg -replace '\s{2,}', ' '

                $appLogs.Add([PSCustomObject]@{
                    Section         = "ApplicationEventLog"
                    TimeCreated     = $entry.TimeCreated.ToString("yyyy-MM-dd HH:mm:ss")
                    EventID         = $eid
                    EventIDMeaning  = Get-AppEventMeaning $eid
                    Level           = $entry.LevelDisplayName
                    Message         = $cleanMsg
                }) | Out-Null
            } catch {
                Write-Warning "Error parsing entry in ApplicationEventLog (EventID $($entry.Id)): $($_.Exception.Message)"
            }
        }
    } catch {
        Write-Warning "Error collecting ApplicationEventLog: $($_.Exception.Message)"
        return $null
    }

    if ($appLogs.Count -eq 0) {
        Write-Warning "No Application event log entries found in ApplicationEventLog."
        return $null
    } else {
        return $appLogs
    }
}

#################################################################################################################################

function Run-SetupEventLog {
    function Get-SetupEventMeaning {
        param ($id)
        switch ($id) {
            1      { "Setup started" }
            2      { "Setup completed" }
            3      { "Setup failed" }
            4      { "Restore started" }
            5      { "Restore completed" }
            6      { "Restore failed" }
            30102  { "Feature Update Started" }
            30103  { "Feature Update Completed" }
            30104  { "Feature Update Failed" }
            20000  { "Windows Update install" }
            default { "Unknown" }
        }
    }

    function Get-KBFromMessage {
        param ($message)
        if ($message -match "(KB\d{6,7})") {
            return $matches[1]
        } else {
            return "N/A"
        }
    }

    $setupLogs = New-Object System.Collections.ArrayList

    try {
        $events = Get-WinEvent -LogName "Setup" -MaxEvents 200 -ErrorAction Stop
        foreach ($event in $events) {
            try {
                $eid = $event.Id
                $cleanMsg = $event.Message -replace "`r`n", " "
                $cleanMsg = $cleanMsg -replace '\s+', ' '
                $kb = Get-KBFromMessage $cleanMsg

                $setupLogs.Add([PSCustomObject]@{
                    Section        = "SetupEventLog"
                    TimeCreated    = $event.TimeCreated.ToString("yyyy-MM-dd HH:mm:ss")
                    EventID        = $eid
                    EventIDMeaning = Get-SetupEventMeaning $eid
                    KB             = $kb
                    Level          = $event.LevelDisplayName
                    Message        = $cleanMsg
                }) | Out-Null
            } catch {
                Write-Warning "Error parsing entry in SetupEventLog (EventID $($event.Id)): $($_.Exception.Message)"
            }
        }
    } catch {
        Write-Warning "Error collecting SetupEventLog: $($_.Exception.Message)"
        return $null
    }

    if ($setupLogs.Count -eq 0) {
        Write-Warning "No Setup event log entries found in SetupEventLog."
        return $null
    } else {
        return $setupLogs
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-WindowsPowerShellLog {
    function Get-PSEventMeaning {
        param ($id)
        switch ($id) {
            400   { "Engine Lifecycle State Changed" }
            403   { "Command Started" }
            600   { "Provider Initialized" }
            800   { "Pipeline Execution Completed" }
            4035  { "Module Loaded" }
            default { "Other/Unknown" }
        }
    }

    $psLogs = New-Object System.Collections.ArrayList

    try {
        $events = Get-WinEvent -LogName "Windows PowerShell" -MaxEvents 100 -ErrorAction Stop
        foreach ($event in $events) {
            try {
                $timeCreated = $event.TimeCreated.ToString("yyyy-MM-dd HH:mm:ss")
                $eventID = $event.Id
                $level = $event.LevelDisplayName
                $message = $event.Message -replace "`r`n", " "
                $message = $message -replace '\s{2,}', ' '
                $meaning = Get-PSEventMeaning $eventID

                $psLogs.Add([PSCustomObject]@{
                    Section        = "WindowsPowerShellLog"
                    TimeCreated    = $timeCreated
                    EventID        = $eventID
                    EventIDMeaning = $meaning
                    Level          = $level
                    Message        = $message
                }) | Out-Null
            } catch {
                Write-Warning "Error parsing entry in WindowsPowerShellLog (EventID $($event.Id)): $($_.Exception.Message)"
            }
        }
    } catch {
        Write-Warning "Error collecting WindowsPowerShellLog: $($_.Exception.Message)"
        return $null
    }

    if ($psLogs.Count -eq 0) {
        Write-Warning "No Windows PowerShell event log entries found in WindowsPowerShellLog."
        return $null
    } else {
        return $psLogs
    }
}

#################################################################################################################################

function Run-PowerShellOperationalLog {
    function Get-PSOpEventMeaning {
        param ($id)
        switch ($id) {
            4100 { "PowerShell Engine Lifecycle Error" }
            4103 { "Pipeline Execution Started" }
            4104 { "ScriptBlock Logging (Executed Code)" }
            4105 { "Command Started" }
            4106 { "Command Completed" }
            default { "Other/Unknown" }
        }
    }

    $psOperational = New-Object System.Collections.ArrayList

    try {
        $events = Get-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational" -MaxEvents 100 -ErrorAction Stop
        foreach ($event in $events) {
            try {
                $timeCreated = $event.TimeCreated.ToString("yyyy-MM-dd HH:mm:ss")
                $eventID = $event.Id
                $level = $event.LevelDisplayName
                $message = $event.Message -replace "`r`n", " "
                $message = $message -replace '\s{2,}', ' '
                $meaning = Get-PSOpEventMeaning $eventID

                $psOperational.Add([PSCustomObject]@{
                    Section        = "PowerShellOperationalLog"
                    TimeCreated    = $timeCreated
                    EventID        = $eventID
                    EventIDMeaning = $meaning
                    Level          = $level
                    Message        = $message
                }) | Out-Null
            } catch {
                Write-Warning "Error parsing entry in PowerShellOperationalLog (EventID $($event.Id)): $($_.Exception.Message)"
            }
        }
    } catch {
        Write-Warning "Error collecting PowerShellOperationalLog: $($_.Exception.Message)"
        return $null
    }

    if ($psOperational.Count -eq 0) {
        Write-Warning "No PowerShell Operational event log entries found in PowerShellOperationalLog."
        return $null
    } else {
        return $psOperational
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-NTUSERDatCheck {
    $ntuserPaths = New-Object System.Collections.ArrayList

    try {
        Get-ChildItem -Path "C:\Users" -Directory -ErrorAction SilentlyContinue | ForEach-Object {
            try {
                $ntPath = Join-Path $_.FullName "NTUSER.DAT"
                if (Test-Path $ntPath -ErrorAction SilentlyContinue) {
                    $item = Get-Item $ntPath -ErrorAction SilentlyContinue

                    $hash = ""
                    try {
                        $hash = (Get-FileHash -Path $ntPath -Algorithm SHA256 -ErrorAction SilentlyContinue).Hash
                    } catch {
                        $hash = "Error generating hash"
                    }

                    $ntuserPaths.Add([PSCustomObject]@{
                        Section      = "NTUSERDat"
                        Username     = $_.Name
                        NTUSERPath   = $ntPath
                        LastModified = $item.LastWriteTime.ToString("yyyy-MM-dd HH:mm:ss")
                        SizeKB       = [math]::Round($item.Length / 1KB, 2)
                        SHA256       = $hash
                    }) | Out-Null
                }
            } catch {
                Write-Warning "Error processing user in NTUSERDat: [$($_.Name)] - $($_.Exception.Message)"
            }
        }
    } catch {
        Write-Warning "Error collecting NTUSERDat: $($_.Exception.Message)"
        return $null
    }

    if ($ntuserPaths.Count -eq 0) {
        Write-Warning "No NTUSER.DAT files found in NTUSERDat."
        return $null
    } else {
        return $ntuserPaths
    }
}

#################################################################################################################################

function Run-RecentDocs {
    $recentDocs = New-Object System.Collections.ArrayList

    try {
        $baseKey = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs"
        if (Test-Path $baseKey) {
            $subKeys = Get-ChildItem -Path $baseKey -ErrorAction SilentlyContinue
            foreach ($subKey in $subKeys) {
                $subPath = $subKey.PSPath
                try {
                    $props = Get-ItemProperty -Path $subPath -ErrorAction SilentlyContinue
                    foreach ($prop in $props.PSObject.Properties) {
                        if ($prop.Name -ne "MRUListEx") {
                            $hash = "N/A"
                            try {
                                if ((Test-Path $prop.Value -ErrorAction SilentlyContinue) -and (Get-Item $prop.Value -ErrorAction SilentlyContinue).PSIsContainer -eq $false) {
                                    $hash = (Get-FileHash -Path $prop.Value -Algorithm SHA256 -ErrorAction SilentlyContinue).Hash
                                }
                            } catch {
                                $hash = "Error generating hash"
                            }

                            $recentDocs.Add([PSCustomObject]@{
                                Section    = "RecentDocs"
                                SubKey     = $subKey.PSChildName
                                ValueName  = $prop.Name
                                ValueType  = $prop.Value.GetType().Name
                                RawValue   = $prop.Value
                                SHA256     = $hash
                            }) | Out-Null
                        }
                    }
                } catch {
                    Write-Warning "Error processing subkey in RecentDocs: $subPath - $($_.Exception.Message)"
                }
            }
        } else {
            Write-Warning "RecentDocs registry key not found in RecentDocs: $baseKey"
            return $null
        }
    } catch {
        Write-Warning "Error collecting RecentDocs: $($_.Exception.Message)"
        return $null
    }

    if ($recentDocs.Count -eq 0) {
        Write-Warning "No RecentDocs entries found in RecentDocs."
        return $null
    } else {
        return $recentDocs
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-UserAssist {
    $userAssist = New-Object System.Collections.ArrayList

    try {
        $uaPath = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\UserAssist"
        if (Test-Path $uaPath) {
            Get-ChildItem -Path $uaPath -Recurse -ErrorAction SilentlyContinue | ForEach-Object {
                $subkey = $_.PSPath
                try {
                    $props = Get-ItemProperty -Path $subkey -ErrorAction SilentlyContinue
                    foreach ($prop in $props.PSObject.Properties) {
                        if (
                            $prop.Name -notmatch "^PS.*" -and
                            $prop.Name -ne "UEME_RUNPATH" -and
                            $null -ne $prop.Value -and
                            ($prop.Value -is [string] -or $prop.Value -is [int] -or $prop.Value -is [datetime])
                        ) {
                            $userAssist.Add([PSCustomObject]@{
                                Section    = "UserAssist"
                                SubKey     = $_.Name
                                ValueName  = $prop.Name
                                ValueType  = $prop.Value.GetType().Name
                                RawValue   = $prop.Value
                            }) | Out-Null
                        }
                    }
                } catch {
                    Write-Warning "Error processing subkey in UserAssist: $subkey - $($_.Exception.Message)"
                }
            }
        } else {
            Write-Warning "UserAssist registry key not found in UserAssist: $uaPath"
            return $null
        }
    } catch {
        Write-Warning "Error collecting UserAssist: $($_.Exception.Message)"
        return $null
    }

    if ($userAssist.Count -eq 0) {
        Write-Warning "No UserAssist entries found in UserAssist."
        return $null
    } else {
        return $userAssist[0..([Math]::Min($userAssist.Count-1, 1047999))]
    }
}

#################################################################################################################################

function Run-ShellBags {
    $shellBags = New-Object System.Collections.ArrayList
    $shellBagKeys = @(
        "HKCU:\Software\Microsoft\Windows\Shell\BagMRU",
        "HKCU:\Software\Microsoft\Windows\Shell\Bags"
    )

    foreach ($key in $shellBagKeys) {
        try {
            $exists = Test-Path $key
            $lastWrite = "N/A"
            if ($exists) {
                try {
                    $regKey = Get-Item -Path $key -ErrorAction Stop
                    $lastWrite = $regKey.LastWriteTime.ToString("yyyy-MM-dd HH:mm:ss")
                } catch {
                    Write-Warning "Error getting LastWriteTime in ShellBags: $key - $($_.Exception.Message)"
                }
            }
            $shellBags.Add([PSCustomObject]@{
                Section    = "ShellBags"
                Path       = $key
                Exists     = $exists
                LastWrite  = $lastWrite
            }) | Out-Null
        } catch {
            Write-Warning "Error processing registry key in ShellBags: $key - $($_.Exception.Message)"
        }
    }

    if ($shellBags.Count -eq 0) {
        Write-Warning "No ShellBags registry keys found in ShellBags."
        return $null
    } else {
        return $shellBags
    }
}

#################################################################################################################################

function Run-TypedPaths {
    $typedPaths = New-Object System.Collections.ArrayList

    try {
        $typedKey = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\TypedPaths"
        if (Test-Path $typedKey) {
            $values = Get-ItemProperty -Path $typedKey -ErrorAction Stop
            foreach ($name in $values.PSObject.Properties.Name) {
                if ($name -notin @("PSPath", "PSParentPath", "PSChildName", "PSDrive", "PSProvider")) {
                    $typedPaths.Add([PSCustomObject]@{
                        Section   = "TypedPaths"
                        EntryName = $name
                        PathValue = $values.$name
                    }) | Out-Null
                }
            }
        } else {
            Write-Warning "TypedPaths registry key not found in TypedPaths: $typedKey"
        }
    } catch {
        Write-Warning "Error collecting TypedPaths: $($_.Exception.Message)"
    }

    if ($typedPaths.Count -eq 0) {
        Write-Warning "No TypedPaths entries found in TypedPaths."
        return $null
    } else {
        return $typedPaths
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-RunMRU {
    $runMRU = New-Object System.Collections.ArrayList

    try {
        $runMRUKey = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU"
        if (Test-Path $runMRUKey) {
            $values = Get-ItemProperty -Path $runMRUKey -ErrorAction SilentlyContinue
            foreach ($name in $values.PSObject.Properties.Name) {
                if ($name -notin @("MRUList", "PSPath", "PSParentPath", "PSChildName", "PSDrive", "PSProvider")) {
                    $runMRU.Add([PSCustomObject]@{
                        Section  = "RunMRU"
                        EntryKey = $name
                        Command  = $values.$name
                    }) | Out-Null
                }
            }
        } else {
            Write-Warning "RunMRU registry key not found in RunMRU: $runMRUKey"
        }
    } catch {
        Write-Warning "Error collecting RunMRU: $($_.Exception.Message)"
    }

    if ($runMRU.Count -eq 0) {
        Write-Warning "No RunMRU entries found in RunMRU."
        return $null
    } else {
        return $runMRU
    }
}

#################################################################################################################################

function Run-JumpLists {
    $jumpListResults = New-Object System.Collections.ArrayList
    $jumpListFolder = "$env:APPDATA\Microsoft\Windows\Recent\AutomaticDestinations"

    try {
        if (Test-Path $jumpListFolder) {
            Get-ChildItem -Path $jumpListFolder -Filter "*.automaticDestinations-ms" -ErrorAction SilentlyContinue | ForEach-Object {
                $jumpListResults.Add([PSCustomObject]@{
                    Section  = "JumpLists"
                    FileName = $_.Name
                    FullPath = $_.FullName
                    Modified = $_.LastWriteTime.ToString("yyyy-MM-dd HH:mm:ss")
                }) | Out-Null
            }
        } else {
            Write-Warning "JumpList folder not found in JumpLists: $jumpListFolder"
        }
    } catch {
        Write-Warning "Error collecting JumpLists: $($_.Exception.Message)"
    }

    if ($jumpListResults.Count -eq 0) {
        Write-Warning "No JumpLists entries found in JumpLists."
        return $null
    } else {
        return $jumpListResults
    }
}

#################################################################################################################################

function Run-ClipboardHistory {
    $clipboardResults = New-Object System.Collections.ArrayList
    $clipHistoryPath = "$env:LOCALAPPDATA\Microsoft\Windows\Clipboard"

    try {
        if (Test-Path $clipHistoryPath) {
            Get-ChildItem -Path $clipHistoryPath -Recurse -ErrorAction Stop | ForEach-Object {
                $clipboardResults.Add([PSCustomObject]@{
                    Section  = "ClipboardHistory"
                    Name     = $_.Name
                    FullPath = $_.FullName
                    Size     = $_.Length
                    Modified = $_.LastWriteTime.ToString("yyyy-MM-dd HH:mm:ss")
                }) | Out-Null
            }
        } else {
            Write-Warning "Clipboard history path not found in ClipboardHistory: $clipHistoryPath"
        }
    } catch {
        Write-Warning "Error collecting ClipboardHistory: $($_.Exception.Message)"
    }

    if ($clipboardResults.Count -eq 0) {
        Write-Warning "No ClipboardHistory entries found in ClipboardHistory."
        return $null
    } else {
        return $clipboardResults
    }
}

#################################################################################################################################

function Run-AccountLockouts {
    $lockouts = New-Object System.Collections.ArrayList

    try {
        $events = Get-WinEvent -LogName "Security" -FilterXPath "*[System[(EventID=4740)]]" -MaxEvents 100 -ErrorAction Stop

        foreach ($evt in $events) {
            try {
                $message = ($evt.Message -replace "`r`n", " ") -replace '\s+', ' '
                $user = if ($message -match "Account Name:\s+([^\s]+)") { $matches[1] } else { "Unknown" }

                $lockouts.Add([PSCustomObject]@{
                    Section     = "AccountLockouts"
                    TimeCreated = $evt.TimeCreated.ToString("yyyy-MM-dd HH:mm:ss")
                    User        = $user
                    Message     = $message
                }) | Out-Null
            } catch {
                Write-Warning "Error parsing AccountLockouts event (Time: $($evt.TimeCreated)): $($_.Exception.Message)"
                $lockouts.Add([PSCustomObject]@{
                    Section     = "AccountLockouts"
                    TimeCreated = $evt.TimeCreated.ToString("yyyy-MM-dd HH:mm:ss")
                    User        = "ParseError"
                    Message     = "Failed to parse message content"
                }) | Out-Null
            }
        }
    } catch {
        Write-Warning "Error collecting AccountLockouts: $($_.Exception.Message)"
    }

    if ($lockouts.Count -eq 0) {
        Write-Warning "No AccountLockouts entries found."
        return $null
    } else {
        return $lockouts
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-CredentialManagerItems {
    $credData = New-Object System.Collections.ArrayList

    try {
        $creds = cmdkey /list 2>&1
        $target = $null
        foreach ($line in $creds) {
            if ($line -match "^Target: (.+)$") {
                $target = $matches[1]
            } elseif ($line -match "^User: (.+)$" -and $target) {
                $credData.Add([PSCustomObject]@{
                    Section    = "CredentialManager"
                    Target     = $target
                    Username   = $matches[1]
                    Retrieved  = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
                }) | Out-Null
                $target = $null
            }
        }
    } catch {
        Write-Warning "Error collecting CredentialManager: $($_.Exception.Message)"
    }

    if ($credData.Count -eq 0) {
        Write-Warning "No CredentialManager entries found in CredentialManager."
        return $null
    } else {
        return $credData
    }
}

#################################################################################################################################

function Run-NetUser {
    $netUsers = New-Object System.Collections.ArrayList

    try {
        $output = net user
        foreach ($line in $output) {
            if ($line -match "^\s*(\w+)\s*$" -and $line -notmatch "The command completed successfully") {
                $netUsers.Add([PSCustomObject]@{
                    Section   = "NetUser"
                    Username  = $matches[1]
                    Collected = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
                }) | Out-Null
            }
        }
    } catch {
        Write-Warning "Error collecting NetUser: $($_.Exception.Message)"
    }

    if ($netUsers.Count -eq 0) {
        Write-Warning "No NetUser entries found in NetUser."
        return $null
    } else {
        return $netUsers
    }
}

#################################################################################################################################

function Run-NetLocalGroup {
    $localGroups = New-Object System.Collections.ArrayList

    try {
        $groups = net localgroup
        foreach ($line in $groups) {
            if ($line -match "^\*?\s*(.+?)\s*$" -and $line -notmatch "^(Alias|---|The command|completed successfully)") {
                $localGroups.Add([PSCustomObject]@{
                    Section    = "NetLocalGroup"
                    GroupName  = $matches[1].Trim()
                    Collected  = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
                }) | Out-Null
            }
        }
    } catch {
        Write-Warning "Error collecting NetLocalGroup: $($_.Exception.Message)"
    }

    if ($localGroups.Count -eq 0) {
        Write-Warning "No NetLocalGroup entries found in NetLocalGroup."
        return $null
    } else {
        return $localGroups
    }
}

#################################################################################################################################

function Run-WhoamiGroups {
    $whoamiGroups = New-Object System.Collections.ArrayList

    try {
        $lines = whoami /groups
        $parse = $false

        foreach ($line in $lines) {
            if ($line -match "^Group Name\s+SID") {
                $parse = $true
                continue
            }

            if ($parse -and $line.Trim() -ne "") {
                $cols = $line -split '\s{2,}'

                if ($cols.Count -ge 2) {
                    $whoamiGroups.Add([PSCustomObject]@{
                        Section    = "WhoamiGroups"
                        GroupName  = $cols[0].Trim()
                        SID        = $cols[1].Trim()
                        Attributes = if ($cols.Count -ge 3) { 
                            ($cols[2..($cols.Count - 1)] -join ', ').Trim() 
                        } else { 
                            "None" 
                        }
                    }) | Out-Null
                }
            }
        }
    } catch {
        Write-Warning "Error collecting WhoamiGroups: $($_.Exception.Message)"
    }

    if ($whoamiGroups.Count -eq 0) {
        Write-Warning "No WhoamiGroups entries found."
        return $null
    } else {
        return $whoamiGroups
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-MACAddresses {
    $macData = New-Object System.Collections.ArrayList

    try {
        $adapters = Get-NetAdapter -Physical -ErrorAction Stop | Where-Object { $_.Status -eq "Up" }
        foreach ($adapter in $adapters) {
            $macData.Add([PSCustomObject]@{
                Section        = "MACAddresses"
                InterfaceAlias = $adapter.Name
                MACAddress     = $adapter.MacAddress
                LinkSpeed      = $adapter.LinkSpeed
            }) | Out-Null
        }
    } catch {
        Write-Warning "Error collecting MACAddresses: $($_.Exception.Message)"
    }

    if ($macData.Count -eq 0) {
        Write-Warning "No MACAddresses entries found in MACAddresses."
        return $null
    } else {
        return $macData
    }
}

#################################################################################################################################

function Run-HostsFile {
    $hostsEntries = New-Object System.Collections.ArrayList
    $hostsPath = "$env:SystemRoot\System32\drivers\etc\hosts"
    $hash = ""

    try {
        if (Test-Path $hostsPath) {
            try {
                $hash = (Get-FileHash -Path $hostsPath -Algorithm SHA256 -ErrorAction SilentlyContinue).Hash
            } catch {
                $hash = "Error generating hash"
            }

            Get-Content $hostsPath | ForEach-Object {
                $line = $_.Trim()
                if ($line -match "^\d{1,3}(\.\d{1,3}){3}") {
                    $tokens = $line -split "\s+"
                    if ($tokens.Count -ge 2) {
                        $hostsEntries.Add([PSCustomObject]@{
                            Section   = "HostsFile"
                            IPAddress = $tokens[0]
                            Hostname  = $tokens[1]
                            SHA256    = $hash
                        }) | Out-Null
                    }
                }
            }
        }
    } catch {
        Write-Warning "Error collecting HostsFile: $($_.Exception.Message)"
    }

    if ($hostsEntries.Count -eq 0) {
        Write-Warning "No HostsFile entries found."
        return $null
    } else {
        return $hostsEntries
    }
}

#################################################################################################################################

function Run-FirewallRules {
    function Get-FwProfileMeaning {
        param ($val)
        switch ($val) {
            0 { "All" }
            1 { "Domain" }
            2 { "Private" }
            4 { "Public" }
            6 { "Private, Public" }
            3 { "Domain, Private" }
            5 { "Domain, Public" }
            7 { "Domain, Private, Public" }
            default { "Unknown" }
        }
    }
    function Get-FwDirection {
        param ($val)
        switch ($val) {
            1 { "Inbound" }
            2 { "Outbound" }
            default { "Unknown" }
        }
    }
    function Get-FwAction {
        param ($val)
        switch ($val) {
            1 { "Allow" }
            2 { "Block" }
            default { "Unknown" }
        }
    }
    function Get-FwEnabled {
        param ($val)
        switch ($val) {
            1 { "True" }
            2 { "False" }
            default { "Unknown" }
        }
    }

    $firewallRules = New-Object System.Collections.ArrayList

    try {
        $netFwRules = Get-NetFirewallRule -ErrorAction Stop
        foreach ($rule in $netFwRules) {
            $firewallRules.Add([PSCustomObject]@{
                Section   = "FirewallRules"
                Name      = $rule.DisplayName
                Enabled   = Get-FwEnabled $rule.Enabled
                Direction = Get-FwDirection $rule.Direction
                Action    = Get-FwAction $rule.Action
                Profile   = Get-FwProfileMeaning $rule.Profile
            }) | Out-Null
        }
    } catch {
        Write-Warning "Error collecting FirewallRules: $($_.Exception.Message)"
    }

    if ($firewallRules.Count -eq 0) {
        Write-Warning "No FirewallRules entries found in FirewallRules."
        return $null
    } else {
        return $firewallRules
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-DNSCache {
    $dnsFormatted = New-Object System.Collections.ArrayList

    try {
        $dnsCacheRaw = ipconfig /displaydns 2>&1 | Where-Object { 
            $_ -match "^\s*Record Name|Record Type|Time To Live|Data" 
        } | ForEach-Object { 
            $_ -replace "^\s+", "" 
        }

        for ($i = 0; $i -lt $dnsCacheRaw.Count; $i += 4) {
            try {
                $recordName = $dnsCacheRaw[$i] -replace "Record Name\s+:\s+", ""
                $recordTypeRaw = $dnsCacheRaw[$i + 1] -replace "Record Type\s+:\s+", ""
                $ttl = $dnsCacheRaw[$i + 2] -replace "Time To Live\s+:\s+", ""
                $data = $dnsCacheRaw[$i + 3] -replace "Data\s+:\s+", ""

                $recordType = switch ($recordTypeRaw) {
                    "1"  { "A (Host Address)" }
                    "5"  { "CNAME (Canonical Name)" }
                    "28" { "AAAA (IPv6 Address)" }
                    default { "Other" }
                }

                $dnsFormatted.Add([PSCustomObject]@{
                    Section    = "DNSCache"
                    RecordName = $recordName
                    RecordType = $recordType
                    TTL        = $ttl
                    Data       = $data
                }) | Out-Null
            } catch {
                Write-Warning "Error parsing entry in DNSCache: $($_.Exception.Message)"
            }
        }
    } catch {
        Write-Warning "Error collecting DNSCache: $($_.Exception.Message)"
    }

    if ($dnsFormatted.Count -eq 0) {
        Write-Warning "No DNSCache entries found."
        return $null
    } else {
        return $dnsFormatted
    }
}

##################################################################################################################################################################################################################################################################

function Run-ARPCache {
    $arpData = New-Object System.Collections.ArrayList

    try {
        $arpRaw = arp -a 2>&1
        $arpLines = $arpRaw | Where-Object { $_ -match "^\s*\d" }
        foreach ($line in $arpLines) {
            try {
                $cols = ($line -replace "^\s+", "") -split "\s+"
                if ($cols.Count -eq 3) {
                    $arpData.Add([PSCustomObject]@{
                        Section    = "ARPCache"
                        IPAddress  = $cols[0]
                        MACAddress = $cols[1]
                        Type       = $cols[2]
                    }) | Out-Null
                }
            } catch {
                Write-Warning "Error parsing entry in ARPCache: $($_.Exception.Message)"
            }
        }
    } catch {
        Write-Warning "Error collecting ARPCache: $($_.Exception.Message)"
    }

    if ($arpData.Count -eq 0) {
        Write-Warning "No ARPCache entries found in ARPCache."
        return $null
    } else {
        return $arpData
    }
}

##################################################################################################################################################################################################################################################################

function Run-LogonEvents {
    $logonEvents = New-Object System.Collections.ArrayList

    try {
        $events = Get-WinEvent -FilterHashtable @{ LogName = "Security"; ID = 4624 } -MaxEvents 100 -ErrorAction Stop

        foreach ($evt in $events) {
            try {
                $message = ($evt.Message -replace "`r`n", " ") -replace '\s+', ' '

                $accountName = if ($message -match "Account Name:\s+(\S+)") { $matches[1] } else { "Unknown" }
                $logonType   = if ($message -match "Logon Type:\s+(\d+)") { $matches[1] } else { "N/A" }
                $logonID     = if ($message -match "Logon ID:\s+(\S+)") { $matches[1] } else { "N/A" }

                $logonEvents.Add([PSCustomObject]@{
                    Section     = "LogonEvents"
                    TimeCreated = $evt.TimeCreated.ToString("yyyy-MM-dd HH:mm:ss")
                    EventID     = $evt.Id
                    Account     = $accountName
                    LogonType   = $logonType
                    LogonID     = $logonID
                    Message     = $message
                }) | Out-Null
            } catch {
                Write-Warning "Error parsing entry in LogonEvents: $($_.Exception.Message)"
            }
        }
    } catch {
        Write-Warning "Error collecting LogonEvents: $($_.Exception.Message)"
    }

    if ($logonEvents.Count -eq 0) {
        Write-Warning "No LogonEvents entries found."
        return $null
    } else {
        return $logonEvents
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-BamDamActivity {
    $bamData = New-Object System.Collections.ArrayList
    $bamPath = "HKLM:\SYSTEM\CurrentControlSet\Services\bam\UserSettings"

    try {
        if (Test-Path $bamPath) {
            Get-ChildItem $bamPath -ErrorAction Stop | ForEach-Object {
                $sid = $_.PSChildName
                try {
                    $properties = Get-ItemProperty -Path $_.PSPath -ErrorAction SilentlyContinue
                    if ($properties) {
                        $properties.PSObject.Properties | Where-Object {
                            $_.Name -notin @("PSPath", "PSParentPath", "PSChildName", "PSDrive", "PSProvider")
                        } | ForEach-Object {
                            try {
                                $lastUsedRaw = $_.Value
                                $lastUsed = try {
                                    ([datetime]::FromFileTimeUtc($lastUsedRaw)).ToString("yyyy-MM-dd HH:mm:ss")
                                } catch {
                                    "Unreadable Timestamp"
                                }
                                $bamData.Add([PSCustomObject]@{
                                    Section    = "BamDamActivity"
                                    UserSID    = $sid
                                    Executable = $_.Name
                                    LastUsed   = $lastUsed
                                }) | Out-Null
                            } catch {
                                Write-Warning "Error parsing entry in BamDamActivity: $($_.Exception.Message)"
                            }
                        }
                    }
                } catch {
                    Write-Warning "Error processing SID $sid in BamDamActivity: $($_.Exception.Message)"
                }
            }
        } else {
            Write-Warning "BamDamActivity registry path not found in BamDamActivity: $bamPath"
        }
    } catch {
        Write-Warning "Error collecting BamDamActivity: $($_.Exception.Message)"
    }

    if ($bamData.Count -eq 0) {
        Write-Warning "No BamDamActivity entries found in BamDamActivity."
        return $null
    } else {
        return $bamData
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-NetstatOutput {
    $netstatData = New-Object System.Collections.ArrayList

    try {
        $netstatRaw = netstat -ano 2>&1 | Select-String "TCP|UDP"

        foreach ($line in $netstatRaw) {
            try {
                $parts = ($line -replace "\s+", " ").Trim() -split " "

                if ($parts.Length -eq 5) {
                    $netstatData.Add([PSCustomObject]@{
                        Section        = "NetstatOutput"
                        Protocol       = $parts[0]
                        LocalAddress   = $parts[1]
                        ForeignAddress = $parts[2]
                        State          = $parts[3]
                        PID            = $parts[4]
                    }) | Out-Null
                } elseif ($parts.Length -eq 4) {
                    $netstatData.Add([PSCustomObject]@{
                        Section        = "NetstatOutput"
                        Protocol       = $parts[0]
                        LocalAddress   = $parts[1]
                        ForeignAddress = $parts[2]
                        State          = "N/A"
                        PID            = $parts[3]
                    }) | Out-Null
                }
            } catch {
                Write-Warning "Error parsing line in NetstatOutput: $($_.Exception.Message)"
            }
        }
    } catch {
        Write-Warning "Error collecting NetstatOutput: $($_.Exception.Message)"
    }

    if ($netstatData.Count -eq 0) {
        Write-Warning "No NetstatOutput entries found."
        return $null
    } else {
        return $netstatData
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-IpconfigDisplayDns {
    $parsedDns = New-Object System.Collections.ArrayList

    try {
        $dnsOutput = ipconfig /displaydns 2>&1
        $dnsFiltered = $dnsOutput | Where-Object { $_ -match "^\s*(Record Name|Record Type|Time To Live|Data)" }

        for ($i = 0; $i -lt $dnsFiltered.Count; $i += 4) {
            try {
                $parsedDns.Add([PSCustomObject]@{
                    Section    = "Ipconfig/displaydns"
                    RecordName = ($dnsFiltered[$i]   -split ":\s*", 2)[1].Trim()
                    RecordType = ($dnsFiltered[$i+1] -split ":\s*", 2)[1].Trim()
                    TTL        = ($dnsFiltered[$i+2] -split ":\s*", 2)[1].Trim()
                    Data       = ($dnsFiltered[$i+3] -split ":\s*", 2)[1].Trim()
                }) | Out-Null
            } catch {
                Write-Warning "Error parsing DNS entry in Ipconfig/displaydns: $($_.Exception.Message)"
            }
        }
    } catch {
        Write-Warning "Error collecting Ipconfig/displaydns: $($_.Exception.Message)"
    }

    if ($parsedDns.Count -eq 0) {
        Write-Warning "No Ipconfig/displaydns entries found."
        return $null
    } else {
        return $parsedDns
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-RDPLogonEvents {
    $rdpLogons = New-Object System.Collections.ArrayList

    try {
        $events = Get-WinEvent -LogName "Microsoft-Windows-TerminalServices-RemoteConnectionManager/Operational" `
            -FilterXPath "*[System[(EventID=1149)]]" -MaxEvents 100 -ErrorAction Stop

        foreach ($evt in $events) {
            try {
                $timeCreated = $evt.TimeCreated.ToString("yyyy-MM-dd HH:mm:ss")
                $eventID = $evt.Id
                $message = $evt.Message -replace "`r`n", " "
                $message = $message -replace '\s{2,}', ' '

                $rdpLogons.Add([PSCustomObject]@{
                    Section     = "RDP Logon Events"
                    TimeCreated = $timeCreated
                    EventID     = $eventID
                    Message     = $message
                }) | Out-Null
            } catch {
                Write-Warning "Error parsing entry in RDP Logon Events (EventID $($evt.Id)): $($_.Exception.Message)"
            }
        }
    } catch {
        Write-Warning "Error collecting RDP Logon Events: $($_.Exception.Message)"
    }

    if ($rdpLogons.Count -eq 0) {
        Write-Warning "No RDP Logon Events entries found."
        return $null
    } else {
        return $rdpLogons
    }
}

##################################################################################################################################################################################################################################################################

function Run-NetworkInterfaces {
    $netAdapters = New-Object System.Collections.ArrayList

    try {
        $adapters = Get-NetAdapter -ErrorAction Stop
        foreach ($adapter in $adapters) {
            try {
                $netAdapters.Add([PSCustomObject]@{
                    Section     = "Network Interfaces"
                    Name        = $adapter.Name
                    Status      = $adapter.Status
                    MACAddress  = $adapter.MacAddress
                    LinkSpeed   = $adapter.LinkSpeed
                    InterfaceID = $adapter.InterfaceIndex
                }) | Out-Null
            } catch {
                Write-Warning "Error processing adapter in Network Interfaces: $($_.Exception.Message)"
            }
        }
    } catch {
        Write-Warning "Error collecting Network Interfaces: $($_.Exception.Message)"
    }

    if ($netAdapters.Count -eq 0) {
        Write-Warning "No Network Interfaces entries found in Network Interfaces."
        return $null
    } else {
        return $netAdapters
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-AppCompatCache {
    $appCompatCache = New-Object System.Collections.ArrayList

    try {
        $regPath = "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\AppCompatCache"
        if (Test-Path $regPath) {
            $appCompatCache.Add([PSCustomObject]@{
                Section = "AppCompatCache"
                Note    = "AppCompatCache value exists, but requires binary parsing (Volatility/ShimCacheParser)"
            }) | Out-Null
        } else {
            $appCompatCache.Add([PSCustomObject]@{
                Section = "AppCompatCache"
                Note    = "AppCompatCache not available or inaccessible"
            }) | Out-Null
        }
    } catch {
        Write-Warning "Error collecting AppCompatCache: $($_.Exception.Message)"
    }

    if ($appCompatCache.Count -eq 0) {
        return $null
    } else {
        return $appCompatCache
    }
}

##################################################################################################################################################################################################################################################################

function Run-MUICache {
    $muiEntries = New-Object System.Collections.ArrayList

    try {
        $muiPath = "HKCU:\Software\Classes\Local Settings\Software\Microsoft\Windows\Shell\MuiCache"
        if (Test-Path $muiPath) {
            $props = Get-ItemProperty -Path $muiPath -ErrorAction Stop
            $props.PSObject.Properties | Where-Object { $_.Name -ne "(default)" -and $_.Name -ne "LangID" } | ForEach-Object {
                try {
                    $desc = if ($_.Value) { $_.Value.ToString().Trim() } else { "N/A" }
                    $muiEntries.Add([PSCustomObject]@{
                        Section     = "MUICache"
                        Executable  = $_.Name
                        Description = $desc
                    }) | Out-Null
                } catch {
                    Write-Warning "Error processing entry in MUICache: $($_.Exception.Message)"
                }
            }
        }
    } catch {
        Write-Warning "Error collecting MUICache: $($_.Exception.Message)"
    }

    if ($muiEntries.Count -eq 0) {
        return $null
    } else {
        return $muiEntries
    }
}

##################################################################################################################################################################################################################################################################

function Run-RecentApps {
    $recentApps = New-Object System.Collections.ArrayList

    try {
        $recentAppsKey = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Search\RecentApps"
        if (Test-Path $recentAppsKey) {
            Get-ChildItem $recentAppsKey -ErrorAction Stop | ForEach-Object {
                try {
                    $app = Get-ItemProperty -Path $_.PSPath -ErrorAction Stop
                    $recentApps.Add([PSCustomObject]@{
                        Section        = "RecentApps"
                        AppID          = $_.PSChildName
                        Executable     = $app.Executable
                        LastAccessTime = $app.LastAccessTime
                    }) | Out-Null
                } catch {
                    Write-Warning "Error collecting RecentApps entry at $($_.PSPath): $($_.Exception.Message)"
                }
            }
        }
    } catch {
        Write-Warning "Error collecting RecentApps: $($_.Exception.Message)"
    }

    if ($recentApps.Count -eq 0) {
        return $null
    } else {
        return $recentApps
    }
}

##################################################################################################################################################################################################################################################################

function Run-RecentFileCache {
    $recentFileCacheData = New-Object System.Collections.ArrayList

    try {
        $recentFileCachePath = "$env:SystemRoot\AppCompat\Programs\RecentFileCache.bcf"
        if (Test-Path $recentFileCachePath) {
            $hash = ""
            try {
                $hash = (Get-FileHash -Path $recentFileCachePath -Algorithm SHA256 -ErrorAction SilentlyContinue).Hash
            } catch {
                $hash = "Error generating hash"
            }

            $recentFileCacheData.Add([PSCustomObject]@{
                Section = "RecentFileCache"
                Path    = $recentFileCachePath
                Note    = "File exists. Binary format. Use external tools like PECmd or AppCompatParser to extract data."
                SHA256  = $hash
            }) | Out-Null
        } else {
            $recentFileCacheData.Add([PSCustomObject]@{
                Section = "RecentFileCache"
                Path    = "N/A"
                Note    = "File not found"
            }) | Out-Null
        }
    } catch {
        Write-Warning "Error collecting RecentFileCache: $($_.Exception.Message)"
    }

    if ($recentFileCacheData.Count -eq 0) {
        return $null
    } else {
        return $recentFileCacheData
    }
}

##################################################################################################################################################################################################################################################################

function Run-SrumData {
    $srumResults = New-Object System.Collections.ArrayList

    try {
        $srumPath = "$env:windir\System32\sru\SRUDB.dat"
        if (Test-Path $srumPath) {
            $srumResults.Add([PSCustomObject]@{
                Section    = "SRUM"
                SRUDB_Path = $srumPath
                Note       = "SRUM database exists. Use external parser like SRUM-Dump or SQLite tools for analysis."
            }) | Out-Null
        } else {
            $srumResults.Add([PSCustomObject]@{
                Section    = "SRUM"
                SRUDB_Path = "Not Found"
                Note       = "SRUDB.dat not found."
            }) | Out-Null
        }
    } catch {
        Write-Warning "Error collecting SRUM: $($_.Exception.Message)"
    }

    if ($srumResults.Count -eq 0) {
        return $null
    } else {
        return $srumResults
    }
}

#################################################################################################################################
#################################################################################################################################

function Run-SamHiveCheck {
    $samCheck = New-Object System.Collections.ArrayList

    try {
        $samPath = "$env:SystemRoot\System32\config\SAM"
        if (Test-Path $samPath) {
            $samCheck.Add([PSCustomObject]@{
                Section = "SAM Hive"
                Hive    = "SAM"
                Path    = $samPath
                Exists  = "Yes"
                Note    = "Binary format, use tools like `reg save` or `secretsdump.py` for analysis"
            }) | Out-Null
        } else {
            $samCheck.Add([PSCustomObject]@{
                Section = "SAM Hive"
                Hive    = "SAM"
                Path    = $samPath
                Exists  = "No"
                Note    = "File not found"
            }) | Out-Null
        }
    } catch {
        Write-Warning "Error collecting SAM Hive: $($_.Exception.Message)"
    }

    if ($samCheck.Count -eq 0) {
        return $null
    } else {
        return $samCheck
    }
}

##################################################################################################################################################################################################################################################################

function Run-SecurityHiveCheck {
    $securityCheck = New-Object System.Collections.ArrayList

    try {
        $securityPath = [System.IO.Path]::Combine($env:SystemRoot, "System32\config\SECURITY")

        if (Test-Path $securityPath) {
            $securityCheck.Add([PSCustomObject]@{
                Section = "SECURITY Hive"
                Hive    = "SECURITY"
                Path    = $securityPath
                Exists  = "Yes"
                Note    = "Binary hive file. Use offline parsing tools for detailed analysis."
            }) | Out-Null
        } else {
            $securityCheck.Add([PSCustomObject]@{
                Section = "SECURITY Hive"
                Hive    = "SECURITY"
                Path    = $securityPath
                Exists  = "No"
                Note    = "File not found"
            }) | Out-Null
        }
    } catch {
        Write-Warning "Error collecting SECURITY Hive: $($_.Exception.Message)"
    }

    if ($securityCheck.Count -eq 0) {
        Write-Warning "No SECURITY Hive data found."
        return $null
    } else {
        return $securityCheck
    }
}

##################################################################################################################################################################################################################################################################

function Run-UsrClassCheck {
    $usrclassCheck = New-Object System.Collections.ArrayList

    try {
        $usrclassPath = [System.IO.Path]::Combine($env:LOCALAPPDATA, "Microsoft\Windows\UsrClass.dat")

        if (Test-Path $usrclassPath) {
            $usrclassCheck.Add([PSCustomObject]@{
                Section = "USRCLASS.DAT"
                File    = "UsrClass.dat"
                Path    = $usrclassPath
                Exists  = "Yes"
                Note    = "ShellBag and Jump List data. Use Registry Explorer or ShellBag parser."
            }) | Out-Null
        } else {
            $usrclassCheck.Add([PSCustomObject]@{
                Section = "USRCLASS.DAT"
                File    = "UsrClass.dat"
                Path    = $usrclassPath
                Exists  = "No"
                Note    = "File not found"
            }) | Out-Null
        }
    } catch {
        Write-Warning "Error collecting USRCLASS.DAT: $($_.Exception.Message)"
    }

    if ($usrclassCheck.Count -eq 0) {
        Write-Warning "No USRCLASS.DAT data found."
        return $null
    } else {
        return $usrclassCheck
    }
}

##################################################################################################################################################################################################################################################################

function Run-PrefetchFiles {
    $prefetchFiles = New-Object System.Collections.ArrayList

    try {
        $prefetchPath = [System.IO.Path]::Combine($env:SystemRoot, "Prefetch")

        if (Test-Path $prefetchPath) {
            Get-ChildItem -Path $prefetchPath -Filter *.pf -ErrorAction SilentlyContinue | ForEach-Object {
                try {
                    $prefetchFiles.Add([PSCustomObject]@{
                        Section  = "PrefetchFiles"
                        Name     = $_.Name
                        Path     = $_.FullName
                        SizeKB   = [math]::Round($_.Length / 1KB, 2)
                        Modified = $_.LastWriteTime
                    }) | Out-Null
                } catch {
                    Write-Warning "Error processing file in PrefetchFiles: $($_.Exception.Message)"
                }
            }
        } else {
            $prefetchFiles.Add([PSCustomObject]@{
                Section  = "PrefetchFiles"
                Name     = "Prefetch Folder Not Found"
                Path     = $prefetchPath
                SizeKB   = "N/A"
                Modified = "N/A"
            }) | Out-Null
        }
    } catch {
        Write-Warning "Error collecting PrefetchFiles: $($_.Exception.Message)"
    }

    if ($prefetchFiles.Count -eq 0) {
        Write-Warning "No PrefetchFiles data found."
        return $null
    } else {
        return $prefetchFiles
    }
}

##################################################################################################################################################################################################################################################################

function Run-AmcacheCheck {
    $amcacheCheck = New-Object System.Collections.ArrayList

    try {
        $amcachePath = [System.IO.Path]::Combine($env:SystemRoot, "AppCompat\Programs\Amcache.hve")

        if (Test-Path $amcachePath) {
            $amcacheCheck.Add([PSCustomObject]@{
                Section = "AmcacheCheck"
                File    = "Amcache.hve"
                Path    = $amcachePath
                Exists  = "Yes"
                Note    = "Binary hive file. Use external parser (e.g., AmcacheParser)"
            }) | Out-Null
        } else {
            $amcacheCheck.Add([PSCustomObject]@{
                Section = "AmcacheCheck"
                File    = "Amcache.hve"
                Path    = $amcachePath
                Exists  = "No"
                Note    = "File not found"
            }) | Out-Null
        }
    } catch {
        Write-Warning "Error collecting AmcacheCheck: $($_.Exception.Message)"
    }

    if ($amcacheCheck.Count -eq 0) {
        Write-Warning "No AmcacheCheck data found."
        return $null
    } else {
        return $amcacheCheck
    }
}

##################################################################################################################################################################################################################################################################

function Run-DownloadsFolder {
    $downloads = New-Object System.Collections.ArrayList

    try {
        $downloadsPath = [System.IO.Path]::Combine([Environment]::GetFolderPath("UserProfile"), "Downloads")

        if (Test-Path $downloadsPath) {
            Get-ChildItem -Path $downloadsPath -Recurse -File -Force -ErrorAction SilentlyContinue | ForEach-Object {
                try {
                    $hash = ""
                    try {
                        $hash = (Get-FileHash -Path $_.FullName -Algorithm SHA256 -ErrorAction SilentlyContinue).Hash
                    } catch {
                        $hash = "Error generating hash"
                    }

                    $downloads.Add([PSCustomObject]@{
                        Section  = "DownloadsFolder"
                        Name     = $_.Name
                        Path     = $_.FullName
                        SizeKB   = [math]::Round($_.Length / 1KB, 2)
                        Modified = $_.LastWriteTime
                        SHA256   = $hash
                    }) | Out-Null
                } catch {
                    Write-Warning "Error processing file in DownloadsFolder: $($_.Exception.Message)"
                }
            }
        } else {
            $downloads.Add([PSCustomObject]@{
                Section  = "DownloadsFolder"
                Name     = "Downloads folder not found"
                Path     = $downloadsPath
                SizeKB   = "N/A"
                Modified = "N/A"
            }) | Out-Null
        }
    } catch {
        Write-Warning "Error collecting DownloadsFolder: $($_.Exception.Message)"
    }

    if ($downloads.Count -eq 0) {
        Write-Warning "No files found in DownloadsFolder."
        return $null
    } else {
        return $downloads
    }
}

##################################################################################################################################################################################################################################################################

function Run-USBHistory {
    $usbHistory = New-Object System.Collections.ArrayList

    try {
        $usbKey = "HKLM:\SYSTEM\CurrentControlSet\Enum\USBSTOR"

        if (Test-Path $usbKey) {
            Get-ChildItem $usbKey -Recurse -ErrorAction SilentlyContinue | ForEach-Object {
                try {
                    $props = Get-ItemProperty -Path $_.PSPath -ErrorAction SilentlyContinue
                    $usbHistory.Add([PSCustomObject]@{
                        Section      = "USBHistory"
                        Device       = $_.PSChildName
                        FriendlyName = $props.FriendlyName
                        Service      = $props.Service
                        ContainerID  = $props.ContainerID
                        PSPath       = $_.PSPath
                    }) | Out-Null
                } catch {
                    Write-Warning "Error processing USB device in USBHistory: $($_.Exception.Message)"
                    $usbHistory.Add([PSCustomObject]@{
                        Section      = "USBHistory"
                        Device       = $_.PSChildName
                        FriendlyName = "Access Error"
                        Service      = "N/A"
                        ContainerID  = "N/A"
                        PSPath       = $_.PSPath
                    }) | Out-Null
                }
            }
        } else {
            $usbHistory.Add([PSCustomObject]@{
                Section      = "USBHistory"
                Device       = "USBSTOR Registry Key Not Found"
                FriendlyName = "N/A"
                Service      = "N/A"
                ContainerID  = "N/A"
                PSPath       = $usbKey
            }) | Out-Null
        }
    } catch {
        Write-Warning "Error collecting USBHistory: $($_.Exception.Message)"
    }

    if ($usbHistory.Count -eq 0) {
        Write-Warning "No USBHistory entries found."
        return $null
    } else {
        return $usbHistory
    }
}

##################################################################################################################################################################################################################################################################

function Run-LnkFiles {
    $lnkFiles = New-Object System.Collections.ArrayList

    try {
        $userDirs = Get-ChildItem "$env:SystemDrive\Users" -Directory -ErrorAction SilentlyContinue

        foreach ($user in $userDirs) {
            $lnkPath = Join-Path $user.FullName "AppData\Roaming\Microsoft\Windows\Recent"

            if (Test-Path $lnkPath) {
                Get-ChildItem -Path $lnkPath -Filter *.lnk -Force -ErrorAction SilentlyContinue | ForEach-Object {
                    try {
                        $lnkFiles.Add([PSCustomObject]@{
                            Section   = "LnkFiles"
                            User      = $user.Name
                            FileName  = $_.Name
                            FullPath  = $_.FullName
                            Modified  = $_.LastWriteTime.ToString("yyyy-MM-dd HH:mm:ss")
                            SizeKB    = [math]::Round($_.Length / 1KB, 2)
                        }) | Out-Null
                    } catch {
                        Write-Warning "Error processing .lnk file in LnkFiles: $($_.Exception.Message)"
                    }
                }
            } else {
                $lnkFiles.Add([PSCustomObject]@{
                    Section   = "LnkFiles"
                    User      = $user.Name
                    FileName  = "N/A"
                    FullPath  = $lnkPath
                    Modified  = "Path Missing"
                    SizeKB    = "N/A"
                }) | Out-Null
            }
        }
    } catch {
        Write-Warning "Error collecting LnkFiles: $($_.Exception.Message)"
    }

    if ($lnkFiles.Count -eq 0) {
        Write-Warning "No LnkFiles entries found."
        return $null
    } else {
        return $lnkFiles
    }
}

##################################################################################################################################################################################################################################################################

function Run-SystemHiveCheck {
    $systemCheck = New-Object System.Collections.ArrayList

    try {
        $systemHivePath = "$env:SystemRoot\System32\config\SYSTEM"

        if (Test-Path $systemHivePath) {
            $systemCheck.Add([PSCustomObject]@{
                Section = "SystemHive"
                Hive    = "SYSTEM"
                Path    = $systemHivePath
                Exists  = "Yes"
                Note    = "Use offline registry parsing tools to analyze"
            }) | Out-Null
        } else {
            $systemCheck.Add([PSCustomObject]@{
                Section = "SystemHive"
                Hive    = "SYSTEM"
                Path    = $systemHivePath
                Exists  = "No"
                Note    = "File not found"
            }) | Out-Null
        }
    } catch {
        Write-Warning "Error collecting SystemHive: $($_.Exception.Message)"
    }

    if ($systemCheck.Count -eq 0) {
        Write-Warning "No SystemHive entries found."
        return $null
    } else {
        return $systemCheck
    }
}

##################################################################################################################################################################################################################################################################

function Run-SoftwareHiveCheck {
    $softwareCheck = New-Object System.Collections.ArrayList

    try {
        $softwareHivePath = "$env:SystemRoot\System32\config\SOFTWARE"

        if (Test-Path $softwareHivePath) {
            $softwareCheck.Add([PSCustomObject]@{
                Section = "SoftwareHive"
                Hive    = "SOFTWARE"
                Path    = $softwareHivePath
                Exists  = "Yes"
                Note    = "Use offline registry parsing tools to analyze"
            }) | Out-Null
        } else {
            $softwareCheck.Add([PSCustomObject]@{
                Section = "SoftwareHive"
                Hive    = "SOFTWARE"
                Path    = $softwareHivePath
                Exists  = "No"
                Note    = "File not found"
            }) | Out-Null
        }
    } catch {
        Write-Warning "Error collecting SoftwareHive: $($_.Exception.Message)"
    }

    if ($softwareCheck.Count -eq 0) {
        Write-Warning "No SoftwareHive entries found."
        return $null
    } else {
        return $softwareCheck
    }
}

##################################################################################################################################################################################################################################################################

function Run-BitLockerStatus {
    $bitlockerCheck = New-Object System.Collections.ArrayList

    try {
        Write-Host "Collecting BitLocker status..." -ForegroundColor Cyan
        $Volumes = Get-BitLockerVolume -ErrorAction SilentlyContinue

        if ($null -eq $Volumes) {
            Write-Warning "No BitLocker volumes detected or access denied."
        }
        else {
            foreach ($Volume in $Volumes) {
                $bitlockerCheck.Add([PSCustomObject]@{
                    Section             = "BitLockerStatus"
                    MountPoint          = $Volume.MountPoint
                    VolumeType          = $Volume.VolumeType
                    ProtectionStatus    = $Volume.ProtectionStatus
                    EncryptionMethod    = $Volume.EncryptionMethod
                    EncryptionPercentage = $Volume.EncryptionPercentage
                    KeyProtector        = ($Volume.KeyProtector | Select-Object -ExpandProperty KeyProtectorType) -join ", "
                }) | Out-Null
            }
        }
    }
    catch {
        Write-Warning "Error collecting BitLocker status: $($_.Exception.Message)"
    }

    if ($bitlockerCheck.Count -eq 0) {
        Write-Warning "No BitLocker information collected."
        return $null
    }
    else {
        return $bitlockerCheck
    }
}

##################################################################################################################################################################################################################################################################

function Run-GroupPolicyResults {
    $gpResults = New-Object System.Collections.ArrayList

    try {
        Write-Host "Collecting Group Policy Results (Computer and User)..." -ForegroundColor Cyan

        # Collect computer and user scope outputs directly
        $ComputerOutput = gpresult /scope computer /r 2>&1
        $UserOutput     = gpresult /scope user /r 2>&1

        if ($ComputerOutput) {
            $gpResults.Add([PSCustomObject]@{
                Section = "GroupPolicyResults_Computer"
                Scope   = "Computer"
                Output  = ($ComputerOutput -join "`r`n")
            }) | Out-Null
        }
        else {
            Write-Warning "No Group Policy Computer scope information collected."
        }

        if ($UserOutput) {
            $gpResults.Add([PSCustomObject]@{
                Section = "GroupPolicyResults_User"
                Scope   = "User"
                Output  = ($UserOutput -join "`r`n")
            }) | Out-Null
        }
        else {
            Write-Warning "No Group Policy User scope information collected."
        }
    }
    catch {
        Write-Warning "An error occurred collecting Group Policy Results: $($_.Exception.Message)"
    }

    if ($gpResults.Count -eq 0) {
        Write-Warning "No Group Policy Results collected."
        return $null
    }
    else {
        return $gpResults
    }
}

##################################################################################################################################################################################################################################################################

function Run-WindowsDefenderStatus {
    $defenderStatus = New-Object System.Collections.ArrayList

    try {
        Write-Host "Collecting Windows Defender status and signature info..." -ForegroundColor Cyan
        $status = Get-MpComputerStatus -ErrorAction Stop

        $defenderStatus.Add([PSCustomObject]@{
            Section                    = "WindowsDefenderStatus"
            'AM Service Enabled'       = $status.AntispywareEnabled
            'Real-Time Protection Enabled' = $status.RealTimeProtectionEnabled
            'Behavior Monitoring Enabled'   = $status.BehaviorMonitorEnabled
            'Signature Version'        = $status.AntivirusSignatureVersion
            'Last Signature Update Time' = $status.AntivirusSignatureLastUpdated
        }) | Out-Null
    }
    catch {
        Write-Warning "Error collecting Windows Defender status: $($_.Exception.Message)"
    }

    if ($defenderStatus.Count -eq 0) {
        Write-Warning "No Windows Defender status collected."
        return $null
    }
    else {
        return $defenderStatus
    }
}

##################################################################################################################################################################################################################################################################

function Run-WERCrashDumps {
    $werDumps = New-Object System.Collections.ArrayList

    try {
        Write-Host "Collecting Windows Error Reporting crash dump files..." -ForegroundColor Cyan

        $dumps = Get-ChildItem -Path "C:\ProgramData\Microsoft\Windows\WER\ReportQueue" -Recurse -Force -ErrorAction SilentlyContinue | 
            Select-Object FullName, LastWriteTime, Length

        if ($dumps.Count -gt 0) {
            foreach ($dump in $dumps) {
                $werDumps.Add([PSCustomObject]@{
                    Section       = "WERCrashDumps"
                    FullName      = $dump.FullName
                    LastWriteTime = $dump.LastWriteTime
                    Length        = $dump.Length
                }) | Out-Null
            }
        }
        else {
            Write-Warning "No WER crash dumps found."
        }
    }
    catch {
        Write-Warning "Error collecting WER crash dumps: $($_.Exception.Message)"
    }

    if ($werDumps.Count -eq 0) {
        Write-Warning "No WER crash dump information collected."
        return $null
    }
    else {
        return $werDumps
    }
}

##################################################################################################################################################################################################################################################################

function Run-ImagesVideosInventory {
    $imageVideoResults = New-Object System.Collections.ArrayList

    try {
        Write-Host "Collecting images, videos, and screenshots..." -ForegroundColor Cyan
        $Extensions = @("*.jpg","*.jpeg","*.png","*.gif","*.bmp","*.tiff","*.heic","*.mp4","*.avi","*.mkv","*.mov","*.wmv","*.flv","*.webm")
        $UserProfile = $env:USERPROFILE
        $Results = @()

        # Full drive scan
        foreach ($Ext in $Extensions) {
            Get-ChildItem -Path "C:\" -Include $Ext -Recurse -ErrorAction SilentlyContinue | ForEach-Object {
                try {
                    $Hash = Get-FileHash -Path $_.FullName -Algorithm SHA256
                    $Results += [PSCustomObject]@{
                        Name           = $_.Name
                        FilePath       = $_.FullName
                        SHA256         = $Hash.Hash
                        CreationTime   = $_.CreationTime
                        LastAccessTime = $_.LastAccessTime
                    }
                }
                catch {
                    Write-Warning "Failed processing file: $($_.FullName)"
                }
            }
        }

        # Explicit screenshot folders
        $ScreenshotFolders = @(
            "$UserProfile\Pictures\Screenshots",
            "$UserProfile\AppData\Local\Packages\Microsoft.ScreenSketch_*",
            "$UserProfile\Pictures\Snips"
        )

        foreach ($folderPattern in $ScreenshotFolders) {
            $resolvedFolders = Get-ChildItem -Path $folderPattern -Directory -ErrorAction SilentlyContinue
            if (-not $resolvedFolders) { $resolvedFolders = @($folderPattern) }
            foreach ($folder in $resolvedFolders) {
                foreach ($Ext in $Extensions) {
                    Get-ChildItem -Path $folder -Include $Ext -Recurse -ErrorAction SilentlyContinue | ForEach-Object {
                        try {
                            $Hash = Get-FileHash -Path $_.FullName -Algorithm SHA256
                            $Results += [PSCustomObject]@{
                                Name           = $_.Name
                                FilePath       = $_.FullName
                                SHA256         = $Hash.Hash
                                CreationTime   = $_.CreationTime
                                LastAccessTime = $_.LastAccessTime
                            }
                        }
                        catch {
                            Write-Warning "Failed processing file: $($_.FullName)"
                        }
                    }
                }
            }
        }

        # Deduplicate by FilePath
        $UniqueResults = $Results | Sort-Object -Property FilePath -Unique

        if ($UniqueResults.Count -gt 0) {
            foreach ($item in $UniqueResults) {
                $imageVideoResults.Add($item) | Out-Null
            }
        }
        else {
            Write-Warning "No images, videos, or screenshots found."
        }
    }
    catch {
        Write-Warning "An error occurred: $($_.Exception.Message)"
    }

    if ($imageVideoResults.Count -eq 0) {
        return $null
    }
    else {
        return $imageVideoResults
    }
}

##################################################################################################################################################################################################################################################################

$SectionMap = @{
    "SYSTEMINFORMATION"         = { Run-SystemInformation }
    "INSTALLEDPROGRAMS"         = { Run-InstalledPrograms }
    "ENVIRONMENTVARIABLES"      = { Run-EnvironmentVariables }
    "UACSETTINGS"               = { Run-UACSettings }
    "WINDOWSVERSIONINFO"        = { Run-WindowsVersionInfo }
    "DESKTOPFILETIMESTAMPS"     = { Run-DesktopFileTimestamps }
    "FILEMETADATA"              = { Run-FileMetadata }
    "HIDDENFILESONC"            = { Run-HiddenFilesOnC }
    "ALTERNATEDATASTREAMS"      = { Run-AlternateDataStreams }
    "FILESACCESSEDLAST14DAYS"   = { Run-FilesAccessedLast14Days }
    "RECYCLEBINCONTENTS"        = { Run-RecycleBinContents }
    "TEMPFOLDERCONTENTS"        = { Run-TempFolderContents }
    "VOLUMESHADOWCOPIES"        = { Run-VolumeShadowCopies }
    "SYMBOLICLINKSANDJUNCTIONS" = { Run-SymbolicLinksAndJunctions }
    "RUNNINGPROCESSES"          = { Run-RunningProcesses }
    "LOADEDDLLS"                = { Run-LoadedDLLs }
    "PROCESSTREEWMI"            = { Run-ProcessTreeWMI }
    "POWERSHELLHISTORY"         = { Run-PowerShellHistory }
    "PARENTCHILDPROCESSTREE"    = { Run-ParentChildProcessTree }
    "WMIACTIVITYLOGS"           = { Run-WmiActivityLogs }
    "SCHEDULEDTASKS"            = { Run-ScheduledTasks }
    "STARTUPFOLDERITEMS"        = { Run-StartupFolderItems }
    "REGISTRYRUNKEYS"           = { Run-RegistryRunKeys }
    "SERVICEINFORMATION"        = { Run-ServiceInformation }
    "WMIEVENTCONSUMERS"         = { Run-WMIEventConsumers }
    "COMHIJACKINGENTRIES"       = { Run-COMHijackingEntries }
    "DLLSEARCHORDERHIJACKS"     = { Run-DLLSearchOrderHijacks }
    "SECURITYEVENTLOG"          = { Run-SecurityEventLog }
    "SYSTEMEVENTLOG"            = { Run-SystemEventLog }
    "APPLICATIONEVENTLOG"       = { Run-ApplicationEventLog }
    "SETUPEVENTLOG"             = { Run-SetupEventLog }
    "WINDOWSPOWERSHELLLOG"      = { Run-WindowsPowerShellLog }
    "POWERSHELLOPERATIONALLOG"  = { Run-PowerShellOperationalLog }
    "NTUSERDAT"                 = { Run-NTUSERDatCheck }
    "RECENTDOCS"                = { Run-RecentDocs }
    "USERASSIST"                = { Run-UserAssist }
    "SHELLBAGS"                 = { Run-ShellBags }
    "TYPEDPATHS"                = { Run-TypedPaths }
    "RUNMRU"                    = { Run-RunMRU }
    "JUMPLISTS"                 = { Run-JumpLists }
    "CLIPBOARDHISTORY"          = { Run-ClipboardHistory }
    "ACCOUNTLOCKOUTS"           = { Run-AccountLockouts }
    "CREDENTIALMANAGER"         = { Run-CredentialManagerItems }
    "NETUSER"                   = { Run-NetUser }
    "NETLOCALGROUP"             = { Run-NetLocalGroup }
    "WHOAMIGROUPS"              = { Run-WhoamiGroups }
    "MACADDRESSES"              = { Run-MACAddresses }
    "HOSTSFILE"                 = { Run-HostsFile }
    "FIREWALLRULES"             = { Run-FirewallRules }
    "DNSCACHE"                  = { Run-DNSCache }
    "ARPCACHE"                  = { Run-ARPCache }
    "LOGONEVENTS"               = { Run-LogonEvents }
    "BAMDAMACTIVITY"            = { Run-BamDamActivity }
    "NETSTATOUTPUT"             = { Run-NetstatOutput }
    "IPCONFIGDISPLAYDNS"        = { Run-IpconfigDisplayDns }
    "RDPLOGONEVENTS"            = { Run-RDPLogonEvents }
    "NETWORKINTERFACES"         = { Run-NetworkInterfaces }
    "APPCOMPATCACHE"            = { Run-AppCompatCache }
    "MUICACHE"                  = { Run-MUICache }
    "RECENTAPPS"                = { Run-RecentApps }
    "RECENTFILECACHE"           = { Run-RecentFileCache }
    "SRUM"                      = { Run-SrumData }
    "SAMHIVE"                   = { Run-SamHiveCheck }
    "SECURITYHIVE"              = { Run-SecurityHiveCheck }
    "USRCLASSDAT"               = { Run-UsrClassCheck }
    "PREFETCHFILES"             = { Run-PrefetchFiles }
    "AMCACHECHECK"              = { Run-AmcacheCheck }
    "DOWNLOADSFOLDER"           = { Run-DownloadsFolder }
    "USBHISTORY"                = { Run-USBHistory }
    "LNKFILES"                  = { Run-LnkFiles }
    "SYSTEMHIVE"                = { Run-SystemHiveCheck }
    "SOFTWAREHIVE"              = { Run-SoftwareHiveCheck }
    "BITLOCKERSTATUS"           = { Run-BitLockerStatus }
    "GROUPPOLICYRESULTS"        = { Run-GroupPolicyResults }
    "WINDOWSDEFENDERSTATUS"     = { Run-WindowsDefenderStatus }
    "WERCRASHDUMPS"             = { Run-WERCrashDumps }
    "IMAGESVIDEOSINVENTORY"     = { Run-ImagesVideosInventory }
}

##################################################################################################################################################################################################################################################################

# Global dictionary to hold results for each section
$script:resultsBySection = @{}

function Export-DataBySection {
    $script:resultsBySection.Clear()

    # Collect data for each section
    foreach ($section in $Sections) {
        $key = $section.ToUpper().Replace(" ", "")
        if ($SectionMap.ContainsKey($key)) {
            try {
                $result = & $SectionMap[$key]
                if ($result) {
                    $script:resultsBySection[$section] = $result
                    Write-Debug "Collected data for section '$section'."
                } else {
                    Write-Debug "No data returned for section '$section'."
                }
            } catch {
                Write-Warning "Error collecting section '$section': $_"
                Write-Debug "Exception collecting section '$section': $_"
            }
        } else {
            Write-Warning "Unknown section: $section"
            Write-Debug "Attempted to collect unknown section: $section"
        }
    }

    if ($script:resultsBySection.Count -eq 0) {
        Write-Warning "No data collected for any selected sections."
        Write-Debug "No sections returned any data."
        return
    }

    # Export to specified format
    switch ($OutputFormat) {
        "XLSX" { Export-DataToExcel }
        "CSV"  { Export-DataToCsv }
        "JSON" { Export-DataToJson }
        "TXT"  { Export-DataToTxt }
        default {
            Write-Warning "Unsupported output format: $OutputFormat"
            Write-Debug "Unsupported output format received: $OutputFormat"
        }
    }

    Verify-ExportedFiles
}

function Export-DataToExcel {
    Import-Module ImportExcel -ErrorAction Stop

    foreach ($sectionName in $script:resultsBySection.Keys) {
        $data = $script:resultsBySection[$sectionName]
        if (-not $data) {
            Write-Debug "Skipping empty section '$sectionName'."
            continue
        }

        if ($data -isnot [System.Collections.ICollection] -or $data -is [string]) {
            $data = @($data)
            Write-Debug "Wrapped single item data for section '$sectionName' into array."
        }

        $safeName = $sectionName -replace '[\\\/\?\*\[\]:]', '_'
        $filePath = Join-Path $dir ("{0}_{1}.xlsx" -f $baseName, $safeName)

        if (Test-Path $filePath) {
            Remove-Item $filePath -Force
            Write-Debug "Removed existing file $filePath"
        }

        try {
            $data | Export-Excel -Path $filePath -WorksheetName $safeName -AutoSize -AutoFilter
            Write-Host "Exported section $sectionName to $filePath"
        } catch {
            Write-Warning "Failed to export section '$sectionName' to Excel file: $_"
        }
    }
}

function Export-DataToCsv {
    foreach ($sectionName in $script:resultsBySection.Keys) {
        $data = $script:resultsBySection[$sectionName]
        if (-not $data) {
            Write-Debug "Skipping empty section '$sectionName'."
            continue
        }

        if ($data -isnot [System.Collections.ICollection] -or $data -is [string]) {
            $data = @($data)
            Write-Debug "Wrapped single item data for section '$sectionName' into array."
        }

        $safeName = $sectionName -replace '[\\\/\?\*\[\]:]', '_'
        $filePath = Join-Path $dir ("{0}_{1}.csv" -f $baseName, $safeName)

        if (Test-Path $filePath) {
            Remove-Item $filePath -Force
            Write-Debug "Removed existing file $filePath"
        }

        try {
            $data | Export-Csv -Path $filePath -NoTypeInformation -Force
            Write-Host "Exported section $sectionName to $filePath"
        } catch {
            Write-Warning "Failed to export section '$sectionName' to CSV file: $_"
        }
    }
}

function Export-DataToJson {
    foreach ($sectionName in $script:resultsBySection.Keys) {
        $data = $script:resultsBySection[$sectionName]
        if (-not $data) {
            Write-Debug "Skipping empty section '$sectionName'."
            continue
        }

        if ($data -isnot [System.Collections.ICollection] -or $data -is [string]) {
            $data = @($data)
        }

        $safeName = $sectionName -replace '[\\\/\?\*\[\]:]', '_'
        $filePath = Join-Path $dir ("{0}_{1}.json" -f $baseName, $safeName)

        if (Test-Path $filePath) {
            Remove-Item $filePath -Force
        }

        try {
            $data | ConvertTo-Json -Depth 5 | Out-File -FilePath $filePath -Force
            Write-Host "Exported section $sectionName to $filePath"
        } catch {
            Write-Warning "Failed to export section '$sectionName' to JSON file: $_"
        }
    }
}

function Export-DataToTxt {
    foreach ($sectionName in $script:resultsBySection.Keys) {
        $data = $script:resultsBySection[$sectionName]
        if (-not $data) {
            Write-Debug "Skipping empty section '$sectionName'."
            continue
        }

        if ($data -isnot [System.Collections.ICollection] -or $data -is [string]) {
            $data = @($data)
        }

        $safeName = $sectionName -replace '[\\\/\?\*\[\]:]', '_'
        $filePath = Join-Path $dir ("{0}_{1}.txt" -f $baseName, $safeName)

        if (Test-Path $filePath) {
            Remove-Item $filePath -Force
        }

        try {
            $data | Out-File -FilePath $filePath -Force
            Write-Host "Exported section $sectionName to $filePath"
        } catch {
            Write-Warning "Failed to export section '$sectionName' to TXT file: $_"
        }
    }
}

function Verify-ExportedFiles {
    foreach ($sectionName in $script:resultsBySection.Keys) {
        $safeName = $sectionName -replace '[\\\/\?\*\[\]:]', '_'
        $extension = "." + $OutputFormat.ToLower()
        $filePath = Join-Path $dir ("{0}_{1}{2}" -f $baseName, $safeName, $extension)

        if (Test-Path $filePath) {
            Write-Host "Output file exists: $filePath"
        } else {
            Write-Warning "Output file missing: $filePath"
        }
    }
}

Export-DataBySection

##################################################################################################################################################################################################################################################################
